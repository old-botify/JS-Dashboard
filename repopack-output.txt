This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-10-22T21:04:32.507Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
components/
  BrandedAnalysis.js
  CategoryAnalysis.js
  CategoryDistribution.js
  CompetitorAnalysis.js
  Dashboard.js
  DataLoader.js
  DynamicSlider.js
  Filters.js
  KeywordTable.js
  Sidebar.js
pages/
  index.js
public/
  _app.js
styles/
  index.css
.gitattributes
.gitignore
next.config.js
nextjs_project_structure.csv
package.json
process.config.js
README.md
structure.py
tailwind.config.js
vercel.json

================================================================
Repository Files
================================================================

================
File: components/BrandedAnalysis.js
================
import React, { useState, useMemo } from 'react';
import { BarChart, Bar, XAxis, YAxis, Tooltip, ResponsiveContainer, Legend } from 'recharts';

const BrandedAnalysis = ({ filteredData, chartMetric }) => {
  const [excludedCategories, setExcludedCategories] = useState([]);

  const toggleCategory = (category) => {
    setExcludedCategories(prev => 
      prev.includes(category) 
        ? prev.filter(c => c !== category)
        : [...prev, category]
    );
  };

  const brandedChartData = useMemo(() => {
    const groupedData = filteredData.reduce((acc, item) => {
      if (!excludedCategories.includes(item.category)) {
        if (!acc[item.category]) {
          acc[item.category] = { 
            category: item.category, 
            brandedSearchVolume: 0, 
            nonBrandedSearchVolume: 0,
            brandedCount: 0,
            nonBrandedCount: 0
          };
        }
        if (item.isBranded) {
          acc[item.category].brandedSearchVolume += item.searchVolume;
          acc[item.category].brandedCount += 1;
        } else {
          acc[item.category].nonBrandedSearchVolume += item.searchVolume;
          acc[item.category].nonBrandedCount += 1;
        }
      }
      return acc;
    }, {});
    return Object.values(groupedData);
  }, [filteredData, excludedCategories]);

  const uniqueCategories = useMemo(() => 
    [...new Set(filteredData.map(item => item.category))],
    [filteredData]
  );

  return (
    <div style={styles.section}>
      <h2 style={styles.sectionTitle}>Branded Analysis</h2>
      <div style={styles.categoryToggle}>
        {uniqueCategories.map(category => (
          <label key={category} style={styles.categoryLabel}>
            <input
              type="checkbox"
              checked={!excludedCategories.includes(category)}
              onChange={() => toggleCategory(category)}
              style={styles.categoryCheckbox}
            />
            {category}
          </label>
        ))}
      </div>
      <div style={styles.chartContainer}>
        <ResponsiveContainer width="100%" height={400}>
          <BarChart data={brandedChartData} margin={{ top: 20, right: 30, left: 20, bottom: 50 }}>
            <XAxis 
              dataKey="category" 
              interval={0}
              tick={{ angle: -45, textAnchor: 'end', fontSize: 12 }}
              height={70}
            />
            <YAxis />
            <Tooltip 
              formatter={(value) => chartMetric === 'searchVolume' ? value.toLocaleString() : value}
              labelFormatter={(label) => `Category: ${label}`}
            />
            <Legend />
            <Bar 
              dataKey={chartMetric === 'searchVolume' ? 'brandedSearchVolume' : 'brandedCount'}
              fill="#4ECDC4"
              name="Branded"
              stackId="a"
            />
            <Bar 
              dataKey={chartMetric === 'searchVolume' ? 'nonBrandedSearchVolume' : 'nonBrandedCount'}
              fill="#FF6B6B"
              name="Non-Branded"
              stackId="a"
            />
          </BarChart>
        </ResponsiveContainer>
      </div>
      <p style={styles.description}>
        This chart shows the distribution of Branded vs Non-Branded keywords across categories based on {chartMetric === 'searchVolume' ? 'search volume' : 'keyword count'}.
      </p>
    </div>
  );
};

const styles = {
  section: {
    backgroundColor: 'white',
    borderRadius: '12px',
    padding: '30px',
    marginBottom: '40px',
    boxShadow: '0 4px 6px rgba(0,0,0,0.1)',
    transition: 'all 0.3s ease',
  },
  sectionTitle: {
    fontSize: '1.8rem',
    marginBottom: '20px',
    color: '#6a0dad',
  },
  chartContainer: {
    width: '100%',
    height: '400px',
  },
  description: {
    marginTop: '20px',
    fontSize: '1rem',
    color: '#666',
    textAlign: 'center',
  },
  categoryToggle: {
    marginBottom: '20px',
    display: 'flex',
    flexWrap: 'wrap',
    gap: '10px',
  },
  categoryLabel: {
    display: 'flex',
    alignItems: 'center',
    fontSize: '0.9rem',
    cursor: 'pointer',
  },
  categoryCheckbox: {
    marginRight: '5px',
  },
};

export default BrandedAnalysis;

================
File: components/CategoryAnalysis.js
================
import React, { useState, useMemo } from 'react';
import { BarChart, Bar, XAxis, YAxis, Tooltip, ResponsiveContainer } from 'recharts';

const CategoryAnalysis = ({ filteredData, chartMetric, setChartMetric }) => {
  const [excludedCategories, setExcludedCategories] = useState([]);

  const toggleCategory = (category) => {
    setExcludedCategories(prev => 
      prev.includes(category) 
        ? prev.filter(c => c !== category)
        : [...prev, category]
    );
  };

  const chartData = useMemo(() => {
    const groupedData = filteredData.reduce((acc, item) => {
      if (!excludedCategories.includes(item.category)) {
        if (!acc[item.category]) {
          acc[item.category] = { category: item.category, searchVolume: 0, count: 0 };
        }
        acc[item.category].searchVolume += item.searchVolume;
        acc[item.category].count += 1;
      }
      return acc;
    }, {});
    return Object.values(groupedData);
  }, [filteredData, excludedCategories]);

  const uniqueCategories = useMemo(() => 
    [...new Set(filteredData.map(item => item.category))],
    [filteredData]
  );

  return (
    <div style={styles.section}>
      <h2 style={styles.sectionTitle}>Category Analysis</h2>
      <div style={styles.controlsContainer}>
        <label htmlFor="chart-metric" style={styles.label}>Select Metric:</label>
        <select 
          id="chart-metric"
          onChange={(e) => setChartMetric(e.target.value)} 
          value={chartMetric}
          style={styles.select}
        >
          <option value="searchVolume">Search Volume</option>
          <option value="count">Keyword Count</option>
        </select>
      </div>
      <div style={styles.categoryToggle}>
        {uniqueCategories.map(category => (
          <label key={category} style={styles.categoryLabel}>
            <input
              type="checkbox"
              checked={!excludedCategories.includes(category)}
              onChange={() => toggleCategory(category)}
              style={styles.categoryCheckbox}
            />
            {category}
          </label>
        ))}
      </div>
      <div style={styles.chartContainer}>
        <ResponsiveContainer width="100%" height={400}>
          <BarChart data={chartData} margin={{ top: 20, right: 30, left: 20, bottom: 50 }}>
            <XAxis 
              dataKey="category" 
              interval={0}
              tick={{ angle: -45, textAnchor: 'end', fontSize: 12 }}
              height={70}
            />
            <YAxis />
            <Tooltip 
              formatter={(value) => chartMetric === 'searchVolume' ? value.toLocaleString() : value}
              labelFormatter={(label) => `Category: ${label}`}
            />
            <Bar 
              dataKey={chartMetric} 
              fill="#6a0dad"
              name={chartMetric === 'searchVolume' ? 'Search Volume' : 'Keyword Count'}
            />
          </BarChart>
        </ResponsiveContainer>
      </div>
    </div>
  );
};

const styles = {
  section: {
    backgroundColor: 'white',
    borderRadius: '12px',
    padding: '30px',
    marginBottom: '40px',
    boxShadow: '0 4px 6px rgba(0,0,0,0.1)',
    transition: 'all 0.3s ease',
  },
  sectionTitle: {
    fontSize: '1.8rem',
    marginBottom: '20px',
    color: '#6a0dad',
  },
  controlsContainer: {
    display: 'flex',
    alignItems: 'center',
    marginBottom: '20px',
  },
  label: {
    marginRight: '10px',
    fontWeight: '600',
  },
  select: {
    padding: '8px 12px',
    borderRadius: '4px',
    border: '1px solid #ddd',
    backgroundColor: 'white',
    fontSize: '1rem',
    color: '#333',
  },
  chartContainer: {
    width: '100%',
    height: '400px',
  },
  categoryToggle: {
    marginBottom: '20px',
    display: 'flex',
    flexWrap: 'wrap',
    gap: '10px',
  },
  categoryLabel: {
    display: 'flex',
    alignItems: 'center',
    fontSize: '0.9rem',
    cursor: 'pointer',
  },
  categoryCheckbox: {
    marginRight: '5px',
  },
};

export default CategoryAnalysis;

================
File: components/CategoryDistribution.js
================
import React, { useState, useMemo } from 'react';
import { PieChart, Pie, Cell, Sector, ResponsiveContainer, Tooltip, Treemap } from 'recharts';
import { FaChartPie, FaThLarge } from 'react-icons/fa';

const COLORS = [
  '#4E79A7', '#F28E2B', '#E15759', '#76B7B2', '#59A14F',
  '#EDC949', '#AF7AA1', '#FF9DA7', '#9C755F', '#BAB0AB',
  '#86BCB6', '#FF9E1B', '#D37295', '#8CD17D', '#B6992D',
  '#499894', '#E15759', '#F28E2B', '#FFBE7D', '#FF6600',
  '#A14C58', '#4E79A7', '#76B7B2', '#FF9DA7', '#FFBF79'
];

const CategoryDistribution = ({ filteredData, chartMetric }) => {
  const [activeIndex, setActiveIndex] = useState(null);
  const [activeIndexVolume, setActiveIndexVolume] = useState(null);
  const [countSortConfig, setCountSortConfig] = useState({ key: null, direction: 'ascending' });
  const [volumeSortConfig, setVolumeSortConfig] = useState({ key: null, direction: 'ascending' });
  const [chartType, setChartType] = useState('doughnut');
  const [excludedCategories, setExcludedCategories] = useState([]);

  const toggleCategory = (category) => {
    setExcludedCategories(prev => 
      prev.includes(category) 
        ? prev.filter(c => c !== category)
        : [...prev, category]
    );
  };

  const pieChartData = useMemo(() => {
    const groupedData = filteredData.reduce((acc, item) => {
      if (!excludedCategories.includes(item.category)) {
        if (!acc[item.category]) {
          acc[item.category] = { category: item.category, searchVolume: 0, count: 0 };
        }
        acc[item.category].searchVolume += item.searchVolume;
        acc[item.category].count += 1;
      }
      return acc;
    }, {});

    const data = Object.values(groupedData);
    const totalSearchVolume = data.reduce((sum, item) => sum + item.searchVolume, 0);
    const totalCount = data.reduce((sum, item) => sum + item.count, 0);

    return data.map(item => ({
      ...item,
      searchVolumePercentage: (item.searchVolume / totalSearchVolume) * 100,
      countPercentage: (item.count / totalCount) * 100
    }));
  }, [filteredData, excludedCategories]);

  const uniqueCategories = useMemo(() => 
    [...new Set(filteredData.map(item => item.category))],
    [filteredData]
  );

  const sortedCountData = useMemo(() => {
    let sortableItems = [...pieChartData];
    if (countSortConfig.key) {
      sortableItems.sort((a, b) => {
        const aValue = countSortConfig.key.includes('Percentage') ? parseFloat(a[countSortConfig.key]) : a[countSortConfig.key];
        const bValue = countSortConfig.key.includes('Percentage') ? parseFloat(b[countSortConfig.key]) : b[countSortConfig.key];
        if (aValue < bValue) {
          return countSortConfig.direction === 'ascending' ? -1 : 1;
        }
        if (aValue > bValue) {
          return countSortConfig.direction === 'ascending' ? 1 : -1;
        }
        return 0;
      });
    }
    return sortableItems;
  }, [pieChartData, countSortConfig]);
  
  const sortedVolumeData = useMemo(() => {
    let sortableItems = [...pieChartData];
    if (volumeSortConfig.key) {
      sortableItems.sort((a, b) => {
        const aValue = volumeSortConfig.key.includes('Percentage') ? parseFloat(a[volumeSortConfig.key]) : a[volumeSortConfig.key];
        const bValue = volumeSortConfig.key.includes('Percentage') ? parseFloat(b[volumeSortConfig.key]) : b[volumeSortConfig.key];
        if (aValue < bValue) {
          return volumeSortConfig.direction === 'ascending' ? -1 : 1;
        }
        if (aValue > bValue) {
          return volumeSortConfig.direction === 'ascending' ? 1 : -1;
        }
        return 0;
      });
    }
    return sortableItems;
  }, [pieChartData, volumeSortConfig]);

  const requestSort = (key, sortConfig, setSortConfig) => {
    let direction = 'ascending';
    if (sortConfig.key === key && sortConfig.direction === 'ascending') {
      direction = 'descending';
    }
    setSortConfig({ key, direction });
  };

  const renderActiveShape = (props) => {
    const { cx, cy, innerRadius, outerRadius, startAngle, endAngle, fill } = props;
    return (
      <g>
        <Sector
          cx={cx}
          cy={cy}
          innerRadius={innerRadius}
          outerRadius={outerRadius + 6}
          startAngle={startAngle}
          endAngle={endAngle}
          fill={fill}
        />
      </g>
    );
  }

  const renderCustomLabel = ({ cx, cy, midAngle, innerRadius, outerRadius, percent, index, name, fill }) => {
    if (percent <= 0.04) return null;
    const RADIAN = Math.PI / 180;
    const radius = outerRadius + 60;
    const x = cx + radius * Math.cos(-midAngle * RADIAN);
    const y = cy + radius * Math.sin(-midAngle * RADIAN);
    const sin = Math.sin(-RADIAN * midAngle);
    const cos = Math.cos(-RADIAN * midAngle);
    const sx = cx + (outerRadius + 10) * cos;
    const sy = cy + (outerRadius + 10) * sin;
    const mx = cx + (outerRadius + 30) * cos;
    const my = cy + (outerRadius + 30) * sin;
    const ex = mx + (cos >= 0 ? 1 : -1) * 22;
    const ey = my;
    const textAnchor = cos >= 0 ? 'start' : 'end';
  
    return (
      <g>
        <text x={x} y={y} fill={fill} textAnchor={x > cx ? 'start' : 'end'} dominantBaseline="central">
          {`${name} ${(percent * 100).toFixed(0)}%`}
        </text>
        <path d={`M${sx},${sy}L${mx},${my}L${ex},${ey}`} stroke={fill} fill="none" />
        <circle cx={ex} cy={ey} r={2} fill={fill} stroke="none" />
      </g>
    );
  };

  const CustomTooltip = ({ active, payload }) => {
    if (active && payload && payload.length) {
      const data = payload[0].payload;
      return (
        <div style={styles.tooltip}>
          <p style={{ margin: '0 0 5px', fontWeight: 'bold', color: data.fill }}>{data.name || data.category}</p>
          <p style={{ margin: '0 0 3px' }}>{`${payload[0].name}: ${payload[0].value.toLocaleString()}`}</p>
          <p style={{ margin: '0' }}>{`Percentage: ${parseFloat(data.percentage || data.countPercentage || data.searchVolumePercentage || 0).toFixed(2)}%`}</p>
        </div>
      );
    }
    return null;
  };

  const renderTreemapCell = (props) => {
    const { x, y, width, height, index, name, depth, root } = props;
    const isKeywordCount = root.name === 'Keyword Count';
    const percentage = isKeywordCount ? props.countPercentage : props.searchVolumePercentage;

    return (
      <g>
        <rect
          x={x}
          y={y}
          width={width}
          height={height}
          style={{
            fill: COLORS[index % COLORS.length],
            stroke: '#fff',
            strokeWidth: 1,
          }}
        />
        <text
          x={x + width / 2}
          y={y + height / 2}
          textAnchor="middle"
          fill="#fff"
          fontSize={10}
          fontWeight="200"
          style={{
            textShadow: '1px 1px 2px rgba(0, 0, 0, 0.5)',
            letterSpacing: '1px',
          }}
        >
          <tspan x={x + width / 2} dy="-0.5em">{name}</tspan>
          {percentage !== undefined && (
            <tspan x={x + width / 2} dy="1.2em">{`${percentage.toFixed(2)}%`}</tspan>
          )}
        </text>
      </g>
    );
  };

  const SortableTable = ({ data, sortConfig, requestSort, type }) => (
    <table style={styles.table}>
      <thead>
        <tr>
          <th style={styles.th} onClick={() => requestSort('category')}>
            Category {sortConfig.key === 'category' && (sortConfig.direction === 'ascending' ? '▲' : '▼')}
          </th>
          <th style={styles.th} onClick={() => requestSort(type === 'count' ? 'count' : 'searchVolume')}>
            {type === 'count' ? 'Count' : 'Volume'} {sortConfig.key === (type === 'count' ? 'count' : 'searchVolume') && (sortConfig.direction === 'ascending' ? '▲' : '▼')}
          </th>
          <th style={styles.th} onClick={() => requestSort(type === 'count' ? 'countPercentage' : 'searchVolumePercentage')}>
            Percentage {sortConfig.key === (type === 'count' ? 'countPercentage' : 'searchVolumePercentage') && (sortConfig.direction === 'ascending' ? '▲' : '▼')}
          </th>
        </tr>
      </thead>
      <tbody>
        {data.map((item, index) => (
          <tr key={item.category} style={{backgroundColor: index % 2 === 0 ? '#f8f9fa' : 'white'}}>
            <td style={styles.td}>{item.category}</td>
            <td style={styles.td}>{type === 'count' ? item.count.toLocaleString() : item.searchVolume.toLocaleString()}</td>
            <td style={styles.td}>{(type === 'count' ? item.countPercentage : item.searchVolumePercentage).toFixed(2)}%</td>
          </tr>
        ))}
      </tbody>
    </table>
  );

  const renderChart = (data, chartType, dataKey, activeIndex, setActiveIndex) => {
    switch (chartType) {
      case 'pie':
      case 'doughnut':
        return (
          <Pie
            data={data}
            dataKey={dataKey}
            nameKey="category"
            cx="50%"
            cy="50%"
            innerRadius={chartType === 'doughnut' ? 60 : 0}
            outerRadius={100}
            fill="#8884d8"
            labelLine={false}
            label={renderCustomLabel}
            activeIndex={activeIndex}
            activeShape={renderActiveShape}
            onMouseEnter={(_, index) => setActiveIndex(index)}
            onMouseLeave={() => setActiveIndex(null)}
          >
            {data.map((entry, index) => (
              <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
            ))}
          </Pie>
        );
      case 'treemap':
        return (
          <Treemap
            data={data}
            dataKey={dataKey}
            aspectRatio={4 / 3}
            stroke="#fff"
            fill="#8884d8"
            content={renderTreemapCell}
          >
            <Tooltip content={<CustomTooltip />} />
          </Treemap>
        );
      default:
        return null;
    }
  };

  const ChartTypeSelector = ({ chartType, setChartType }) => (
    <div style={styles.selectorContainer}>
      <div style={styles.selectorGroup}>
        <button
          style={{
            ...styles.selectorButton,
            backgroundColor: chartType === 'doughnut' ? '#6a0dad' : 'white',
            color: chartType === 'doughnut' ? 'white' : '#6a0dad',
          }}
          onClick={() => setChartType('doughnut')}
        >
          Doughnut
        </button>
        <button
          style={{
            ...styles.selectorButton,
            backgroundColor: chartType === 'pie' ? '#6a0dad' : 'white',
            color: chartType === 'pie' ? 'white' : '#6a0dad',
          }}
          onClick={() => setChartType('pie')}
        >
          <FaChartPie style={styles.icon} /> Pie
        </button>
        <button
          style={{
            ...styles.selectorButton,
            backgroundColor: chartType === 'treemap' ? '#6a0dad' : 'white',
            color: chartType === 'treemap' ? 'white' : '#6a0dad',
          }}
          onClick={() => setChartType('treemap')}
        >
          <FaThLarge style={styles.icon} /> Treemap
        </button>
      </div>
    </div>
  );

  return (
    <div style={styles.section}>
      <h2 style={styles.sectionTitle}>Category Distribution</h2>
      <ChartTypeSelector chartType={chartType} setChartType={setChartType} />
      <div style={styles.categoryToggle}>
        {uniqueCategories.map(category => (
          <label key={category} style={styles.categoryLabel}>
            <input
              type="checkbox"
              checked={!excludedCategories.includes(category)}
              onChange={() => toggleCategory(category)}
              style={styles.categoryCheckbox}
            />
            {category}
          </label>
        ))}
      </div>
      <div style={styles.flexContainer}>
        <div style={styles.chartContainer}>
          <h3 style={styles.chartTitle}>By Keyword Count</h3>
          <ResponsiveContainer width="100%" height={400}>
            {chartType === 'treemap' ? (
              <Treemap
                data={[{
                  name: 'Keyword Count',
                  children: pieChartData.map(item => ({
                    name: item.category,
                    size: item.count,
                    countPercentage: item.countPercentage || 0
                  }))
                }]}
                dataKey="size"
                ratio={4/3}
                stroke="#fff"
                fill="#8884d8"
                content={renderTreemapCell}
              >
                <Tooltip content={<CustomTooltip />} />
              </Treemap>
            ) : (
              <PieChart>
                {renderChart(pieChartData, chartType, "count", activeIndex, setActiveIndex)}
                <Tooltip content={<CustomTooltip />} />
              </PieChart>
            )}
          </ResponsiveContainer>
          <div style={styles.tableContainer}>
            <SortableTable 
              data={sortedCountData} 
              sortConfig={countSortConfig} 
              requestSort={(key) => requestSort(key, countSortConfig, setCountSortConfig)}
              type="count"
            />
          </div>
        </div>
        <div style={styles.chartContainer}>
          <h3 style={styles.chartTitle}>By Search Volume</h3>
          <ResponsiveContainer width="100%" height={400}>
            {chartType === 'treemap' ? (
              <Treemap
                data={[{
                  name: 'Search Volume',
                  children: pieChartData.map(item => ({
                    name: item.category,
                    size: item.searchVolume,
                    searchVolumePercentage: item.searchVolumePercentage || 0
                  }))
                }]}
                dataKey="size"
                ratio={4/3}
                stroke="#fff"
                fill="#8884d8"
                content={renderTreemapCell}
              >
                <Tooltip content={<CustomTooltip />} />
              </Treemap>
            ) : (
              <PieChart>
                {renderChart(pieChartData, chartType, "searchVolume", activeIndexVolume, setActiveIndexVolume)}
                <Tooltip content={<CustomTooltip />} />
              </PieChart>
            )}
          </ResponsiveContainer>
          <div style={styles.tableContainer}>
            <SortableTable 
              data={sortedVolumeData} 
              sortConfig={volumeSortConfig} 
              requestSort={(key) => requestSort(key, volumeSortConfig, setVolumeSortConfig)}
              type="volume"
            />
          </div>
        </div>
      </div>
    </div>
  );
};

const styles = {
  section: {
    backgroundColor: 'white',
    borderRadius: '12px',
    padding: '30px',
    marginBottom: '40px',
    boxShadow: '0 4px 6px rgba(0,0,0,0.1)',
    transition: 'all 0.3s ease',
  },
  sectionTitle: {
    fontSize: '1.8rem',
    marginBottom: '20px',
    color: '#6a0dad',
  },
  flexContainer: {
    display: 'flex',
    flexWrap: 'wrap',
    gap: '30px',
  },
  chartContainer: {
    flex: '1 1 400px',
  },
  chartTitle: {
    textAlign: 'center',
    marginBottom: '20px',
    fontSize: '1.2rem',
  },
  tableContainer: {
    marginTop: '20px',
  },
  table: {
    width: '100%',
    borderCollapse: 'collapse',
  },
  th: {
    backgroundColor: '#6a0dad',
    color: 'white',
    padding: '10px',
    textAlign: 'left',
    cursor: 'pointer',
  },
  td: {
    padding: '8px',
    borderBottom: '1px solid #ddd',
  },
  tooltip: {
    backgroundColor: 'rgba(255, 255, 255, 0.9)',
    padding: '12px',
    border: '1px solid #ccc',
    borderRadius: '4px',
    boxShadow: '0 2px 5px rgba(0,0,0,0.1)',
  },
  selectorContainer: {
    display: 'flex',
    justifyContent: 'center',
    width: '100%',
  },
  selectorGroup: {
    display: 'inline-flex',
    borderRadius: '8px',
    overflow: 'hidden',
    boxShadow: 'rgba(0, 0, 0, 0.1) 0px 2px 4px',
  },
  selectorButton: {
    padding: '10px 15px',
    border: 'none',
    cursor: 'pointer',
    fontSize: '14px',
    fontWeight: 'bold',
    transition: 'background-color 0.3s, color 0.3s',
    display: 'flex',
    alignItems: 'center',
  },
  icon: {
    marginRight: '5px',
    fontSize: '16px',
  },
  categoryToggle: {
    marginBottom: '20px',
    display: 'flex',
    flexWrap: 'wrap',
    gap: '10px',
  },
  categoryLabel: {
    display: 'flex',
    alignItems: 'center',
    fontSize: '0.9rem',
    cursor: 'pointer',
  },
  categoryCheckbox: {
    marginRight: '5px',
  },
};

export default CategoryDistribution;

================
File: components/CompetitorAnalysis.js
================
import React, { useState, useRef, useEffect, useMemo } from 'react';
import { BarChart, Bar, XAxis, YAxis, Tooltip, Legend, ResponsiveContainer, PieChart, Pie, Cell, Treemap } from 'recharts';
import { FaChartPie, FaThLarge, FaInfoCircle, FaTimes } from 'react-icons/fa';

const COLORS = [
  '#4E79A7', '#F28E2B', '#E15759', '#76B7B2', '#59A14F',
  '#EDC949', '#AF7AA1', '#FF9DA7', '#9C755F', '#BAB0AB',
  '#86BCB6', '#FF9E1B', '#D37295', '#8CD17D', '#B6992D',
  '#499894', '#E15759', '#F28E2B', '#FFBE7D', '#FF6600',
  '#A14C58', '#4E79A7', '#76B7B2', '#FF9DA7', '#FFBF79'
];

const EXTENDED_COLORS = [...COLORS, '#8A2BE2', '#20B2AA', '#FF4500', '#32CD32', '#FF1493', '#1E90FF'];

const CTR_BY_POSITION = {
  1: 0.398, 2: 0.187, 3: 0.102, 4: 0.072, 5: 0.051,
  6: 0.044, 7: 0.030, 8: 0.021, 9: 0.019, 10: 0.016,
  11: 0.014, 12: 0.012, 13: 0.010, 14: 0.009, 15: 0.008,
  16: 0.007, 17: 0.006, 18: 0.005, 19: 0.004, 20: 0.003
};

const CompetitorAnalysis = ({ filteredData, competitorDataType, setCompetitorDataType }) => {
  const [showTooltip, setShowTooltip] = useState(false);
  const [showFullTable, setShowFullTable] = useState(false);
  const tooltipRef = useRef(null);
  const buttonRef = useRef(null);

  const [competitorSortConfig, setCompetitorSortConfig] = useState({ key: null, direction: 'ascending' });
  const [activeIndexPie, setActiveIndexPie] = useState(null);
  const [chartType, setChartType] = useState('doughnut');

  const competitors = useMemo(() => {
    const allCompetitors = new Set();
    filteredData.forEach(item => {
      item.competitors.forEach(comp => {
        allCompetitors.add(comp.name);
      });
    });
    return Array.from(allCompetitors);
  }, [filteredData]);

  const competitorColors = useMemo(() => 
    Object.fromEntries(competitors.map((comp, index) => 
      [comp, comp === 'client.com' ? 'url(#clientGradient)' : EXTENDED_COLORS[index % EXTENDED_COLORS.length]]
    ))
  , [competitors]);

  const competitorRankingData = useMemo(() => {
    const rankData = Array.from({ length: 20 }, (_, i) => ({
      rank: i + 1,
      total: 0,
      totalVolume: 0,
      totalTraffic: 0,
      ...competitors.reduce((acc, comp) => ({ ...acc, [comp]: 0, [`${comp}Volume`]: 0, [`${comp}Traffic`]: 0 }), {})
    }));

    filteredData.forEach(item => {
      item.competitors.forEach(comp => {
        if (comp.rank <= 20) {
          rankData[comp.rank - 1][comp.name]++;
          rankData[comp.rank - 1].total++;
          rankData[comp.rank - 1][`${comp.name}Volume`] += item.searchVolume;
          rankData[comp.rank - 1].totalVolume += item.searchVolume;
          const estimatedTraffic = item.searchVolume * CTR_BY_POSITION[comp.rank];
          rankData[comp.rank - 1][`${comp.name}Traffic`] += estimatedTraffic;
          rankData[comp.rank - 1].totalTraffic += estimatedTraffic;
        }
      });
    });

    rankData.forEach(rankItem => {
      competitors.forEach(comp => {
        rankItem[`${comp}Percentage`] = rankItem.total > 0 
          ? (rankItem[comp] / rankItem.total * 100).toFixed(2)
          : '0.00';
        rankItem[`${comp}VolumePercentage`] = rankItem.totalVolume > 0
          ? (rankItem[`${comp}Volume`] / rankItem.totalVolume * 100).toFixed(2)
          : '0.00';
        rankItem[`${comp}TrafficPercentage`] = rankItem.totalTraffic > 0
          ? (rankItem[`${comp}Traffic`] / rankItem.totalTraffic * 100).toFixed(2)
          : '0.00';
      });
      rankItem.sortedCompetitors = competitors
        .sort((a, b) => rankItem[b] - rankItem[a])
        .filter(comp => rankItem[comp] > 0);
    });

    return rankData;
  }, [filteredData, competitors]);

  const competitorTotalData = useMemo(() => {
    const totals = competitors.reduce((acc, comp) => ({ ...acc, [comp]: 0, [`${comp}Volume`]: 0, [`${comp}Traffic`]: 0 }), {});
    competitorRankingData.forEach(rankData => {
      competitors.forEach(comp => {
        totals[comp] += rankData[comp];
        totals[`${comp}Volume`] += rankData[`${comp}Volume`];
        totals[`${comp}Traffic`] += rankData[`${comp}Traffic`];
      });
    });
    const totalKeywords = competitors.reduce((sum, comp) => sum + totals[comp], 0);
    const totalVolume = competitors.reduce((sum, comp) => sum + totals[`${comp}Volume`], 0);
    const totalTraffic = competitors.reduce((sum, comp) => sum + totals[`${comp}Traffic`], 0);
    return competitors.map(comp => ({
      name: comp,
      value: totals[comp],
      percentage: (totals[comp] / totalKeywords * 100).toFixed(2),
      volume: totals[`${comp}Volume`],
      volumePercentage: (totals[`${comp}Volume`] / totalVolume * 100).toFixed(2),
      traffic: totals[`${comp}Traffic`],
      trafficPercentage: (totals[`${comp}Traffic`] / totalTraffic * 100).toFixed(2)
    }));
  }, [competitorRankingData, competitors]);

  const sortedCompetitorData = useMemo(() => {
    let sortableItems = [...competitorTotalData];
    if (competitorSortConfig.key) {
        sortableItems.sort((a, b) => {
            let aValue, bValue;
            
            if (competitorDataType === 'count') {
                aValue = parseFloat(a[competitorSortConfig.key === 'percentage' ? 'percentage' : 'value']);
                bValue = parseFloat(b[competitorSortConfig.key === 'percentage' ? 'percentage' : 'value']);
            } else if (competitorDataType === 'volume') {
                aValue = parseFloat(a[competitorSortConfig.key === 'volumePercentage' ? 'volumePercentage' : 'volume']);
                bValue = parseFloat(b[competitorSortConfig.key === 'volumePercentage' ? 'volumePercentage' : 'volume']);
            } else {
                aValue = parseFloat(a[competitorSortConfig.key === 'trafficPercentage' ? 'trafficPercentage' : 'traffic']);
                bValue = parseFloat(b[competitorSortConfig.key === 'trafficPercentage' ? 'trafficPercentage' : 'traffic']);
            }

            if (aValue < bValue) {
                return competitorSortConfig.direction === 'ascending' ? -1 : 1;
            }
            if (aValue > bValue) {
                return competitorSortConfig.direction === 'ascending' ? 1 : -1;
            }
            return 0;
        });
    }
    return sortableItems;
  }, [competitorTotalData, competitorSortConfig, competitorDataType]);

  const requestSort = (key) => {
    let direction = 'ascending';
    if (competitorSortConfig.key === key && competitorSortConfig.direction === 'ascending') {
      direction = 'descending';
    }
    setCompetitorSortConfig({ key, direction });
  };

  const formatLegend = (value) => {
    return value.replace('Volume', '');
  };

  const treemapData = competitorTotalData.map(item => ({
    name: item.name,
    size: competitorDataType === 'count' ? item.value : competitorDataType === 'volume' ? item.volume : item.traffic,
    percentage: competitorDataType === 'count' ? item.percentage : competitorDataType === 'volume' ? item.volumePercentage : item.trafficPercentage
  }));

  const CompetitorTooltip = ({ active, payload }) => {
    if (active && payload && payload.length) {
      const data = payload[0].payload;
      return (
        <div style={styles.tooltip}>
          <p style={{ margin: '0 0 5px', fontWeight: 'bold', color: data.fill || '#000' }}>{data.name}</p>
          <p style={{ margin: '0 0 3px' }}>
            {competitorDataType === 'count' 
              ? `Keyword Count: ${(data.value || data.size).toLocaleString()}`
              : competitorDataType === 'volume'
                ? `Search Volume: ${(data.volume || data.size).toLocaleString()}`
                : `Estimated Traffic: ${(data.traffic || data.size).toLocaleString()}`
            }
          </p>
          <p style={{ margin: '0' }}>
            {`Percentage: ${data.percentage || (data.size / treemapData.reduce((sum, item) => sum + item.size, 0) * 100).toFixed(2)}%`}
          </p>
        </div>
      );
    }
    return null;
  };

  const renderCustomLabel = ({ cx, cy, midAngle, innerRadius, outerRadius, percent, index, name, fill }) => {
    const RADIAN = Math.PI / 180;
    const radius = outerRadius + 70;
    const x = cx + radius * Math.cos(-midAngle * RADIAN);
    const y = cy + radius * Math.sin(-midAngle * RADIAN);
    const sin = Math.sin(-RADIAN * midAngle);
    const cos = Math.cos(-RADIAN * midAngle);
    const sx = cx + (outerRadius + 10) * cos;
    const sy = cy + (outerRadius + 10) * sin;
    const mx = cx + (outerRadius + 30) * cos;
    const my = cy + (outerRadius + 30) * sin;
    const ex = mx + (cos >= 0 ? 1 : -1) * 22;
    const ey = my;
    const textAnchor = cos >= 0 ? 'start' : 'end';

    return (
      <g>
        <text x={x} y={y} fill={fill} textAnchor={textAnchor} dominantBaseline="central">
          {`${name} ${(percent * 100).toFixed(0)}%`}
        </text>
        <path d={`M${sx},${sy}L${mx},${my}L${ex},${ey}`} stroke={fill} fill="none" />
        <circle cx={ex} cy={ey} r={2} fill={fill} stroke="none" />
      </g>
    );
  };

  const renderTreemapCell = (props) => {
    const { x, y, width, height, name, index, percentage } = props;
    return (
      <g>
        <rect
          x={x}
          y={y}
          width={width}
          height={height}
          style={{
            fill: name === 'client.com' ? 'url(#clientGradient)' : competitorColors[name],
            stroke: '#fff',
            strokeWidth: 2,
          }}
        />
        <text
          x={x + width / 2}
          y={y + height / 2}
          textAnchor="middle"
          fill="#fff"
          fontSize={12}
          fontWeight="200"
          letterSpacing="1px"
        >
          {`${name} (${percentage}%)`}
        </text>
      </g>
    );
  };

  const CompetitorTable = ({ data, sortConfig, requestSort, dataType }) => (
    <table style={styles.table}>
      <thead>
        <tr>
          <th style={styles.th} onClick={() => requestSort('name')}>
            Competitor {sortConfig.key === 'name' && (sortConfig.direction === 'ascending' ? '▲' : '▼')}
          </th>
          <th style={styles.th} onClick={() => requestSort(dataType === 'count' ? 'value' : dataType === 'volume' ? 'volume' : 'traffic')}>
            Total {dataType === 'count' ? 'Keywords' : dataType === 'volume' ? 'Search Volume' : 'Estimated Traffic'} {sortConfig.key === (dataType === 'count' ? 'value' : dataType === 'volume' ? 'volume' : 'traffic') && (sortConfig.direction === 'ascending' ? '▲' : '▼')}
          </th>
          <th style={styles.th} onClick={() => requestSort(dataType === 'count' ? 'percentage' : dataType === 'volume' ? 'volumePercentage' : 'trafficPercentage')}>
            Percentage {sortConfig.key === (dataType === 'count' ? 'percentage' : dataType === 'volume' ? 'volumePercentage' : 'trafficPercentage') && (sortConfig.direction === 'ascending' ? '▲' : '▼')}
          </th>
        </tr>
      </thead>
      <tbody>
      {data.map((item, index) => (
          <tr key={item.name} style={{backgroundColor: index % 2 === 0 ? '#f8f9fa' : 'white'}}>
            <td style={styles.td}>{item.name}</td>
            <td style={styles.td}>
              {dataType === 'count' 
                ? item.value.toLocaleString() 
                : dataType === 'volume'
                  ? item.volume.toLocaleString()
                  : item.traffic.toLocaleString()}
            </td>
            <td style={styles.td}>
              {dataType === 'count' 
                ? parseFloat(item.percentage).toFixed(2)
                : dataType === 'volume'
                  ? parseFloat(item.volumePercentage).toFixed(2)
                  : parseFloat(item.trafficPercentage).toFixed(2)}%
            </td>
          </tr>
        ))}
      </tbody>
    </table>
  );
  
  const ShareOfVoiceInfo = () => (
    <div ref={tooltipRef} style={styles.infoBox}>
      <div style={styles.infoHeader}>
        <h3 style={styles.infoTitle}>Share of Voice Explanation</h3>
        <FaTimes style={styles.closeButton} onClick={() => setShowTooltip(false)} />
      </div>
      <p>Share of Voice is an estimate of the traffic a competitor receives based on their ranking positions and assumed Click-Through Rates (CTR) for each position.</p>
      <p>Calculation: For each keyword, we multiply the search volume by the assumed CTR for the competitor's ranking position.</p>
      
      <h4 style={styles.exampleTitle}>Example Calculation:</h4>
      <div style={styles.exampleBox}>
        <p><strong>Keyword:</strong> "beauty box subscription"</p>
        <p><strong>Search Volume:</strong> 10,000 monthly searches</p>
        <p><strong>Competitor A Ranking:</strong> Position 3</p>
        <p><strong>Assumed CTR for Position 3:</strong> 10.2%</p>
        <p><strong>Share of Voice Calculation:</strong></p>
        <p style={styles.calculation}>10,000 × 10.2% = 1,020 estimated monthly clicks</p>
        <p>Therefore, Competitor A's Share of Voice for this keyword is estimated at 1,020 monthly clicks.</p>
      </div>
  
      <h4 style={styles.tableTitle}>Assumed Click-Through Rates by Position:</h4>
      <p style={styles.sourceNote}>Source for positions 1-10: <a href="https://firstpagesage.com/reports/google-click-through-rates-ctrs-by-ranking-position/" target="_blank" rel="noopener noreferrer">First Page Sage CTR Report</a></p>
      <p style={styles.sourceNote}>Note: CTRs for positions 11-20 are estimated based on a logarithmic decay model.</p>
      <table style={styles.infoTable}>
        <thead>
          <tr>
            <th style={styles.tableHeader}>Position</th>
            <th style={styles.tableHeader}>Assumed CTR</th>
          </tr>
        </thead>
        <tbody>
          {Object.entries(CTR_BY_POSITION).slice(0, showFullTable ? 20 : 10).map(([position, ctr]) => (
            <tr key={position} style={styles.tableRow}>
              <td style={styles.tableCell}>{position}</td>
              <td style={styles.tableCell}>{(ctr * 100).toFixed(1)}%</td>
            </tr>
          ))}
        </tbody>
      </table>
      {!showFullTable && (
        <button style={styles.showMoreButton} onClick={() => setShowFullTable(true)}>
          Show positions 11-20
        </button>
      )}
    </div>
  );
  
  useEffect(() => {
    const handleClickOutside = (event) => {
      if (tooltipRef.current && !tooltipRef.current.contains(event.target) &&
          buttonRef.current && !buttonRef.current.contains(event.target)) {
        setShowTooltip(false);
      }
    };
  
    document.addEventListener('mousedown', handleClickOutside);
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, []);
  
  const toggleTooltip = (e) => {
    e.stopPropagation();
    setShowTooltip(!showTooltip);
  };
  
  return (
    <div style={styles.section}>
      <h2 style={styles.sectionTitle}>Competitor Analysis</h2>
      <div style={styles.controlsContainer}>
        <div style={styles.selectorGroup}>
          <button
            style={{
              ...styles.selectorButton,
              backgroundColor: competitorDataType === 'count' ? '#6a0dad' : 'white',
              color: competitorDataType === 'count' ? 'white' : '#6a0dad',
            }}
            onClick={() => setCompetitorDataType('count')}
          >
            Keyword Count
          </button>
          <button
            style={{
              ...styles.selectorButton,
              backgroundColor: competitorDataType === 'volume' ? '#6a0dad' : 'white',
              color: competitorDataType === 'volume' ? 'white' : '#6a0dad',
            }}
            onClick={() => setCompetitorDataType('volume')}
          >
            Search Volume
          </button>
          <div style={styles.buttonContainer}>
            <button
              ref={buttonRef}
              style={{
                ...styles.selectorButton,
                backgroundColor: competitorDataType === 'traffic' ? '#6a0dad' : 'white',
                color: competitorDataType === 'traffic' ? 'white' : '#6a0dad',
              }}
              onClick={() => setCompetitorDataType('traffic')}
            >
              <span style={styles.buttonText}>Share of Voice</span>
              <FaInfoCircle 
                style={styles.infoIcon}
                onClick={toggleTooltip}
              />
            </button>
            {showTooltip && <ShareOfVoiceInfo />}
          </div>
        </div>
      </div>
      <div style={styles.chartContainer}>
        <ResponsiveContainer width="100%" height={500}>
          <BarChart data={competitorRankingData} margin={{ top: 20, right: 30, left: 60, bottom: 140 }}>
            <defs>
              <linearGradient id="clientGradient" x1="0" y1="0" x2="1" y2="0">
                <stop offset="0%" stopColor="#FF9A8B" />
                <stop offset="50%" stopColor="#FF6A88" />
                <stop offset="100%" stopColor="#FF99AC" />
              </linearGradient>
            </defs>
            <XAxis 
              dataKey="rank" 
              label={{ value: 'Rank', position: 'bottom', offset: 20 }}
              tick={{ fontSize: 12 }}
            />
            <YAxis 
              label={{ 
                value: competitorDataType === 'count' 
                  ? 'Number of Keywords' 
                  : competitorDataType === 'volume'
                    ? 'Search Volume'
                    : 'Estimated Traffic',
                angle: -90, 
                position: 'insideLeft', 
                offset: -40 
              }}
              tick={{ fontSize: 12 }}
            />
            <Tooltip
              content={({ active, payload, label }) => {
                if (active && payload && payload.length) {
                  const dataPoint = competitorRankingData[label - 1];
                  return (
                    <div style={styles.tooltip}>
                      <p style={{ fontWeight: 'bold', marginBottom: '5px' }}>{`Rank: ${label}`}</p>
                      {dataPoint.sortedCompetitors.map((comp) => (
                        <p key={comp} style={{ color: competitorColors[comp], margin: '3px 0' }}>
                          {competitorDataType === 'count' 
                            ? `${comp}: ${dataPoint[comp].toLocaleString()} (${dataPoint[`${comp}Percentage`]}%)`
                            : competitorDataType === 'volume'
                              ? `${comp}: ${dataPoint[`${comp}Volume`].toLocaleString()} (${dataPoint[`${comp}VolumePercentage`]}%)`
                              : `${comp}: ${dataPoint[`${comp}Traffic`].toLocaleString()} (${dataPoint[`${comp}TrafficPercentage`]}%)`
                          }
                        </p>
                      ))}
                    </div>
                  );
                }
                return null;
              }}
            />
            <Legend 
              verticalAlign="bottom" 
              height={36} 
              offset={40}
              wrapperStyle={{ paddingTop: '60px' }}
            />
            {competitors.map((competitor, index) => (
              <Bar
                key={competitor}
                dataKey={
                  competitorDataType === 'count' 
                    ? competitor 
                    : competitorDataType === 'volume'
                      ? `${competitor}Volume`
                      : `${competitor}Traffic`
                }
                stackId="a"
                fill={competitor === 'client.com' ? '#FF6A88' : COLORS[index % COLORS.length]}
                name={competitor}
              />
            ))}
          </BarChart>
        </ResponsiveContainer>
      </div>
      <div style={styles.pieChartContainer}>
        <h3 style={styles.chartTitle}>
          Competitor Distribution by {
            competitorDataType === 'count' 
              ? 'Keyword Count' 
              : competitorDataType === 'volume'
                ? 'Search Volume'
                : 'Share of Voice'
          }
        </h3>
        <div style={styles.chartTypeSelector}>
          <button
            style={{
              ...styles.chartTypeButton,
              backgroundColor: chartType === 'doughnut' ? '#6a0dad' : 'white',
              color: chartType === 'doughnut' ? 'white' : '#6a0dad',
            }}
            onClick={() => setChartType('doughnut')}
          >
            Doughnut
          </button>
          <button
            style={{
              ...styles.chartTypeButton,
              backgroundColor: chartType === 'pie' ? '#6a0dad' : 'white',
              color: chartType === 'pie' ? 'white' : '#6a0dad',
            }}
            onClick={() => setChartType('pie')}
          >
            <FaChartPie style={styles.icon} /> Pie
          </button>
          <button
            style={{
              ...styles.chartTypeButton,
              backgroundColor: chartType === 'treemap' ? '#6a0dad' : 'white',
              color: chartType === 'treemap' ? 'white' : '#6a0dad',
            }}
            onClick={() => setChartType('treemap')}
          >
            <FaThLarge style={styles.icon} /> Treemap
          </button>
        </div>
        <ResponsiveContainer width="100%" height={600}>
          {chartType === 'treemap' ? (
            <Treemap
              data={treemapData}
              dataKey="size"
              ratio={4/3}
              stroke="#fff"
              fill="#8884d8"
              content={renderTreemapCell}
            >
              <Tooltip content={<CompetitorTooltip />} />
            </Treemap>
          ) : (
            <PieChart>
              <Pie
                data={competitorTotalData}
                dataKey={competitorDataType === 'count' ? 'value' : competitorDataType === 'volume' ? 'volume' : 'traffic'}
                nameKey="name"
                cx="50%"
                cy="50%"
                outerRadius={200}
                innerRadius={chartType === 'doughnut' ? 120 : 0}
                fill="#8884d8"
                labelLine={true}
                label={renderCustomLabel}
                onMouseEnter={(_, index) => setActiveIndexPie(index)}
                onMouseLeave={() => setActiveIndexPie(null)}
              >
                {competitorTotalData.map((entry, index) => (
                  <Cell 
                    key={`cell-${index}`} 
                    fill={entry.name === 'client.com' ? 'url(#clientGradient)' : competitorColors[entry.name]}
                  />
                ))}
              </Pie>
              <Tooltip content={<CompetitorTooltip />} />
            </PieChart>
          )}
        </ResponsiveContainer>
      </div>
      
      <div style={styles.tableContainer}>
        <h3 style={styles.chartTitle}>Competitor Rankings</h3>
        <CompetitorTable 
          data={sortedCompetitorData} 
          sortConfig={competitorSortConfig} 
          requestSort={requestSort}
          dataType={competitorDataType}
        />
      </div>
    </div>
  );
};
const styles = {
  section: {
    backgroundColor: 'white',
    borderRadius: '12px',
    padding: '30px',
    marginBottom: '40px',
    boxShadow: '0 4px 6px rgba(0,0,0,0.1)',
    transition: 'all 0.3s ease',
  },
  sectionTitle: {
    fontSize: '1.8rem',
    marginBottom: '20px',
    color: '#6a0dad',
  },
  controlsContainer: {
    display: 'flex',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: '20px',
  },
  selectorGroup: {
    display: 'flex',
    borderRadius: '8px',
    overflow: 'hidden',
    boxShadow: '0 2px 4px rgba(0,0,0,0.1)',
  },
  selectorButton: {
    padding: '10px 15px',
    border: 'none',
    cursor: 'pointer',
    fontSize: '14px',
    fontWeight: 'bold',
    transition: 'background-color 0.3s, color 0.3s',
    display: 'flex',
    alignItems: 'center',
  },
  buttonContainer: {
    position: 'relative',
    display: 'inline-block',
  },
  buttonText: {
    marginRight: '8px',
  },
  infoIcon: {
    fontSize: '14px',
    cursor: 'pointer',
  },
  icon: {
    marginRight: '5px',
    fontSize: '16px',
  },
  chartContainer: {
    width: '100%',
    height: '500px',
    marginBottom: '40px',
  },
  pieChartContainer: {
    width: '100%',
    height: '700px',
    marginBottom: '40px',
  },
  chartTitle: {
    textAlign: 'center',
    marginBottom: '20px',
    fontSize: '1.2rem',
  },
  tableContainer: {
    marginTop: '40px',
  },
  table: {
    width: '100%',
    borderCollapse: 'collapse',
  },
  th: {
    backgroundColor: '#6a0dad',
    color: 'white',
    padding: '10px',
    textAlign: 'left',
    cursor: 'pointer',
  },
  td: {
    padding: '8px',
    borderBottom: '1px solid #ddd',
  },
  tooltip: {
    backgroundColor: 'rgba(255, 255, 255, 0.9)',
    padding: '12px',
    border: '1px solid #ccc',
    borderRadius: '4px',
    boxShadow: '0 2px 5px rgba(0,0,0,0.1)',
  },
  infoBox: {
    position: 'fixed',
    top: '50%',
    left: '50%',
    transform: 'translate(-50%, -50%)',
    backgroundColor: 'white',
    border: '1px solid #ccc',
    borderRadius: '4px',
    padding: '20px',
    maxWidth: '400px',
    boxShadow: '0 4px 6px rgba(0,0,0,0.1)',
    zIndex: 9999,
    maxHeight: '80vh',
    overflowY: 'auto',
  },
  infoHeader: {
    display: 'flex',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: '15px',
  },
  infoTitle: {
    margin: 0,
    fontSize: '18px',
    fontWeight: 'bold',
  },
  closeButton: {
    cursor: 'pointer',
    fontSize: '20px',
    color: '#666',
  },
  exampleTitle: {
    marginTop: '20px',
    marginBottom: '10px',
    fontSize: '16px',
    fontWeight: 'bold',
  },
  exampleBox: {
    backgroundColor: '#f8f8f8',
    border: '1px solid #ddd',
    borderRadius: '4px',
    padding: '15px',
    marginBottom: '20px',
  },
  calculation: {
    fontWeight: 'bold',
    color: '#6a0dad',
    marginTop: '10px',
    marginBottom: '10px',
  },
  tableTitle: {
    marginTop: '20px',
    marginBottom: '10px',
    fontSize: '16px',
    fontWeight: 'bold',
  },
  infoTable: {
    width: '100%',
    borderCollapse: 'collapse',
    marginTop: '15px',
    border: '1px solid #ddd',
  },
  tableHeader: {
    backgroundColor: '#f2f2f2',
    padding: '10px',
    textAlign: 'left',
    borderBottom: '1px solid #ddd',
  },
  tableRow: {
    backgroundColor: '#f8f8f8',
  },
  tableCell: {
    padding: '8px',
    borderBottom: '1px solid #ddd',
  },
  showMoreButton: {
    marginTop: '10px',
    padding: '5px 10px',
    backgroundColor: '#6a0dad',
    color: 'white',
    border: 'none',
    borderRadius: '4px',
    cursor: 'pointer',
    fontSize: '14px',
  },
  sourceNote: {
    fontSize: '12px',
    color: '#666',
    marginBottom: '10px',
  },
  chartTypeSelector: {
    display: 'flex',
    justifyContent: 'center',
    marginBottom: '20px',
  },
  chartTypeButton: {
    padding: '10px 15px',
    border: 'none',
    cursor: 'pointer',
    fontSize: '14px',
    fontWeight: 'bold',
    transition: 'background-color 0.3s, color 0.3s',
    display: 'flex',
    alignItems: 'center',
    margin: '0 5px',
    borderRadius: '4px',
  },
};

export default CompetitorAnalysis;

================
File: components/Dashboard.js
================
import React, { useState, useMemo, useCallback } from 'react';
import { BarChart, Bar, XAxis, YAxis, Tooltip, ResponsiveContainer } from 'recharts';
import Select from 'react-select';
import Slider from 'rc-slider';
import KeywordTable from './KeywordTable';
import CategoryAnalysis from './CategoryAnalysis';
import QuestionsAnalysis from './BrandedAnalysis.js';
import CategoryDistribution from './CategoryDistribution';
import CompetitorAnalysis from './CompetitorAnalysis';

const Dashboard = () => {
  const [categoryFilters, setCategoryFilters] = useState([]);
  const [searchVolumeFilter, setSearchVolumeFilter] = useState(0);
  const [brandedFilter, setBrandedFilter] = useState(false);
  const [keywordFilter, setKeywordFilter] = useState('');
  const [chartMetric, setChartMetric] = useState('searchVolume');
  const [currentPage, setCurrentPage] = useState(1);
  const [showCompetitors, setShowCompetitors] = useState(true);
  const [selectedCompetitors, setSelectedCompetitors] = useState([]);
  const [rankRange, setRankRange] = useState([1, 10]);
  const [competitorDataType, setCompetitorDataType] = useState('count');
  const [selectedKeywords, setSelectedKeywords] = useState(new Set());
  const [activeView, setActiveView] = useState('keywordTable');

  const filteredData = useMemo(() => {
    return keywordData.filter(item => {
      const categoryMatch = categoryFilters.length === 0 || categoryFilters.includes(item.category);
      const volumeMatch = item.searchVolume >= searchVolumeFilter;
      const brandedMatch = !brandedFilter || item.isBranded;
      const keywordMatch = keywordFilter === '' || 
        keywordFilter.split(',').some(keyword => 
          item.keyword.toLowerCase().includes(keyword.trim().toLowerCase())
        );
      const competitorMatch = item.competitors.some(comp => 
        (selectedCompetitors.length === 0 || selectedCompetitors.includes(comp.name)) &&
        comp.rank >= rankRange[0] && comp.rank <= rankRange[1]
      );

      return categoryMatch && volumeMatch && questionMatch && keywordMatch && competitorMatch;
    });
  }, [categoryFilters, searchVolumeFilter, questionFilter, keywordFilter, selectedCompetitors, rankRange]);

  const categories = useMemo(() => [...new Set(keywordData.map(item => item.category))], []);

  const competitors = useMemo(() => {
    const allCompetitors = new Set();
    keywordData.forEach(item => {
      item.competitors.forEach(comp => {
        allCompetitors.add(comp.name);
      });
    });
    return Array.from(allCompetitors);
  }, []);

  const competitorOptions = useMemo(() => 
    competitors.map(comp => ({ value: comp, label: comp }))
  , [competitors]);

  const handleCategoryChange = useCallback((event) => {
    const value = event.target.value;
    setCategoryFilters(prev => {
      if (prev.includes(value)) {
        return prev.filter(cat => cat !== value);
      } else {
        return [...prev, value];
      }
    });
  }, []);

  const handleKeywordSelect = useCallback((keyword) => {
    setSelectedKeywords(prev => {
      const newSet = new Set(prev);
      if (newSet.has(keyword)) {
        newSet.delete(keyword);
      } else {
        newSet.add(keyword);
      }
      return newSet;
    });
  }, []);

  return (
    <div className="max-w-7xl mx-auto p-8 bg-gray-50 text-gray-800">
      <h1 className="text-4xl font-bold text-center text-purple-700 pb-5 mb-10 border-b-2 border-purple-700">Content Gap Analysis Dashboard</h1>
      
      <div className="bg-white rounded-lg p-8 mb-10 shadow-md">
        <h2 className="text-2xl font-semibold mb-6 text-purple-700">Filters</h2>
        <div className="flex flex-wrap gap-8">
          <div className="flex-1 min-w-[200px]">
            <label className="block mb-2 font-semibold">Categories</label>
            <div className="max-h-48 overflow-y-auto p-3 border border-gray-300 rounded-lg">
              {categories.map(category => (
                <label key={category} className="block mb-2 text-sm">
                  <input
                    type="checkbox"
                    value={category}
                    checked={categoryFilters.includes(category)}
                    onChange={handleCategoryChange}
                    className="mr-2 accent-purple-700"
                  />
                  {category}
                </label>
              ))}
            </div>
          </div>

          <div className="flex-1 min-w-[200px]">
            <label htmlFor="search-volume-filter" className="block mb-2 font-semibold">Minimum Search Volume</label>
            <input
              id="search-volume-filter"
              type="number"
              value={searchVolumeFilter}
              onChange={(e) => setSearchVolumeFilter(Number(e.target.value))}
              className="w-full p-3 border border-gray-300 rounded-lg"
            />
          </div>

          <div className="flex-1 min-w-[200px]">
            <label className="flex items-center mb-2 font-semibold">
              <input
                type="checkbox"
                checked={questionFilter}
                onChange={(e) => setQuestionFilter(e.target.checked)}
                className="mr-2 accent-purple-700"
              />
              Questions Only
            </label>
          </div>

          <div className="flex-1 min-w-[200px]">
            <label htmlFor="keyword-filter" className="block mb-2 font-semibold">Keyword Filter</label>
            <input
              id="keyword-filter"
              type="text"
              value={keywordFilter}
              onChange={(e) => setKeywordFilter(e.target.value)}
              placeholder="e.g., keyword one, keyword two"
              className="w-full p-3 border border-gray-300 rounded-lg"
            />
          </div>

          <div className="flex-1 min-w-[200px]">
            <label className="flex items-center mb-2 font-semibold">
              <input
                type="checkbox"
                checked={showCompetitors}
                onChange={(e) => setShowCompetitors(e.target.checked)}
                className="mr-2 accent-purple-700"
              />
              Show Competitors
            </label>
          </div>

          {showCompetitors && (
            <>
              <div className="flex-1 min-w-[200px]">
                <label className="block mb-2 font-semibold">Select Competitors</label>
                <Select
                  isMulti
                  options={competitorOptions}
                  value={selectedCompetitors.map(comp => ({ value: comp, label: comp }))}
                  onChange={(selected) => setSelectedCompetitors(selected.map(option => option.value))}
                />
              </div>

              <div className="flex-1 min-w-[200px]">
                <label className="block mb-2 font-semibold">Rank Range</label>
                <Slider
                  range
                  min={1}
                  max={50}
                  defaultValue={rankRange}
                  onChange={setRankRange}
                  className="w-full mt-3"
                />
                <div className="mt-2">
                  Showing ranks {rankRange[0]} to {rankRange[1]}
                </div>
              </div>
            </>
          )}
        </div>
      </div>

      <div className="mb-8">
        <h2 className="text-2xl font-semibold mb-4 text-purple-700">Select View</h2>
        <div className="flex space-x-4">
          <button
            onClick={() => setActiveView('keywordTable')}
            className={`px-4 py-2 rounded ${activeView === 'keywordTable' ? 'bg-purple-700 text-white' : 'bg-gray-200'}`}
          >
            Keyword Table
          </button>
          <button
            onClick={() => setActiveView('categoryAnalysis')}
            className={`px-4 py-2 rounded ${activeView === 'categoryAnalysis' ? 'bg-purple-700 text-white' : 'bg-gray-200'}`}
          >
            Category Analysis
          </button>
          <button
            onClick={() => setActiveView('competitorAnalysis')}
            className={`px-4 py-2 rounded ${activeView === 'competitorAnalysis' ? 'bg-purple-700 text-white' : 'bg-gray-200'}`}
          >
            Competitor Analysis
          </button>
        </div>
      </div>

      {activeView === 'keywordTable' && (
        <KeywordTable
          filteredData={filteredData}
          currentPage={currentPage}
          setCurrentPage={setCurrentPage}
          showCompetitors={showCompetitors}
          selectedKeywords={selectedKeywords}
          handleKeywordSelect={handleKeywordSelect}
        />
      )}

      {activeView === 'categoryAnalysis' && (
        <>
          <CategoryAnalysis
            filteredData={filteredData}
            chartMetric={chartMetric}
            setChartMetric={setChartMetric}
          />
          <QuestionsAnalysis
            filteredData={filteredData}
            chartMetric={chartMetric}
          />
          <CategoryDistribution
            filteredData={filteredData}
            chartMetric={chartMetric}
          />
        </>
      )}

      {activeView === 'competitorAnalysis' && (
        <CompetitorAnalysis
          filteredData={filteredData}
          competitorDataType={competitorDataType}
          setCompetitorDataType={setCompetitorDataType}
        />
      )}
    </div>
  );
};

export default Dashboard;

================
File: components/DataLoader.js
================
import React, { useState, useEffect } from 'react';

const DataLoader = ({ onDataLoad, isLoading }) => {
  const [url, setUrl] = useState('');
  const [error, setError] = useState('');

  const handleLoad = async () => {
    if (!url) {
      setError('Please enter a URL');
      return;
    }

    try {
      const response = await fetch(url);
      
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      
      const text = await response.text();
      
      // Handle JS module format
      let data;
      try {
        // Clean the text: remove export statement, semicolons, and any trailing commas
        const cleanedText = text
          .replace(/export\s+const\s+keywordData\s*=\s*/, '') // Remove export statement
          .replace(/;$/, '') // Remove trailing semicolon
          .replace(/,(\s*[\]}])/g, '$1') // Remove trailing commas
          .trim();

        // Parse the remaining JSON array
        try {
          data = JSON.parse(cleanedText);
        } catch (jsonError) {
          // If JSON parse fails, try eval with safety checks
          if (cleanedText.startsWith('[') && cleanedText.endsWith(']')) {
            // Use Function constructor instead of eval for better safety
            const safeEval = new Function('return ' + cleanedText);
            data = safeEval();
          } else {
            throw new Error('Data must be an array');
          }
        }
        
        if (Array.isArray(data)) {
          onDataLoad(data);
          setError('');
          localStorage.setItem('lastUsedDataUrl', url);
        } else {
          throw new Error('Data is not an array');
        }
      } catch (parseError) {
        console.error('Parse error:', parseError);
        console.error('First 100 chars of cleaned text:', cleanedText.substring(0, 100));
        setError(`Error parsing data: ${parseError.message}. Make sure the file contains a valid array of objects.`);
      }
    } catch (err) {
      console.error('Fetch error:', err);
      setError(`Error loading data: ${err.message}`);
    }
  };

  // Load last used URL from localStorage
  useEffect(() => {
    const lastUrl = localStorage.getItem('lastUsedDataUrl');
    if (lastUrl) {
      setUrl(lastUrl);
    }
  }, []);

  return (
    <div className="bg-white rounded-lg p-6 mb-8 shadow-md">
      <div className="flex flex-col sm:flex-row gap-4">
        <input
          type="url"
          value={url}
          onChange={(e) => setUrl(e.target.value)}
          placeholder="Enter data URL (e.g., https://storage.googleapis.com/public-force-directed-json/kay.js)"
          className="flex-1 px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500"
        />
        <button
          onClick={handleLoad}
          disabled={isLoading}
          className={`px-6 py-2 bg-purple-700 text-white rounded-lg hover:bg-purple-800 transition-colors 
            ${isLoading ? 'opacity-50 cursor-not-allowed' : ''}`}
        >
          {isLoading ? (
            <span className="flex items-center">
              <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
              </svg>
              Loading...
            </span>
          ) : (
            'Load Data'
          )}
        </button>
      </div>
      {error && (
        <div className="mt-4 p-4 bg-red-50 border-l-4 border-red-500 text-red-700">
          <p className="font-bold">Error</p>
          <p>{error}</p>
          <p className="mt-2 text-sm">
            Make sure your data file:
            <ul className="list-disc ml-5 mt-1">
              <li>Starts with 'export const keywordData = ['</li>
              <li>Contains a valid array of objects</li>
              <li>Each object has keyword, category, searchVolume, isBranded, and competitors properties</li>
            </ul>
          </p>
        </div>
      )}
      <div className="mt-4 text-sm text-gray-600">
        <p>Expected format: JavaScript module exporting keywordData array</p>
        <p>File should contain: export const keywordData = [...]</p>
      </div>
    </div>
  );
};

export default DataLoader;

================
File: components/DynamicSlider.js
================
import React, { useState, useEffect } from 'react';
import dynamic from 'next/dynamic';

const Slider = dynamic(() => import('rc-slider'), {
  ssr: false,
});

const DynamicSlider = (props) => {
  const [mounted, setMounted] = useState(false);

  useEffect(() => {
    setMounted(true);
  }, []);

  if (!mounted) {
    return null;
  }

  return <Slider {...props} />;
};

export default DynamicSlider;

================
File: components/Filters.js
================
import React, { useState, useMemo } from 'react';
import Select from 'react-select';
import { FaChevronDown, FaChevronUp } from 'react-icons/fa';

export default function Filters({
  data, // Add this prop
  categoryFilters,
  setCategoryFilters,
  searchVolumeFilter,
  setSearchVolumeFilter,
  brandedFilter,
  setBrandedFilter,
  keywordFilter,
  setKeywordFilter,
  showCompetitors,
  setShowCompetitors,
  selectedCompetitors,
  setSelectedCompetitors,
  rankRange,
  setRankRange
}) {
  const [isFiltersVisible, setIsFiltersVisible] = useState(true);

  const categories = useMemo(() => 
    [...new Set(data.map(item => item.category))],
    [data]
  );
  
  const categoryOptions = useMemo(() => 
    categories.map(category => ({ value: category, label: category }))
  , [categories]);

  const competitors = useMemo(() => {
    const allCompetitors = new Set();
    data.forEach(item => {
      item.competitors.forEach(comp => {
        allCompetitors.add(comp.name);
      });
    });
    return Array.from(allCompetitors);
  }, [data]);

  const competitorOptions = useMemo(() => 
    competitors.map(comp => ({ value: comp, label: comp }))
  , [competitors]);

  const handleCategoryChange = (selectedOptions) => {
    setCategoryFilters(selectedOptions.map(option => option.value));
  };

  const handleCompetitorChange = (selectedOptions) => {
    setSelectedCompetitors(selectedOptions.map(option => option.value));
  };

  const handleRankRangeChange = (type, value) => {
    const newValue = parseInt(value, 10);
    if (isNaN(newValue) || newValue < 0 || newValue > 100) return;

    if (type === 'min') {
      setRankRange([newValue, Math.max(newValue, rankRange[1])]);
    } else {
      setRankRange([Math.min(rankRange[0], newValue), newValue]);
    }
  };

  const customStyles = {
    control: (provided) => ({
      ...provided,
      borderColor: '#ddd',
      '&:hover': {
        borderColor: '#6a0dad'
      }
    }),
    option: (provided, state) => ({
      ...provided,
      backgroundColor: state.isSelected ? '#6a0dad' : state.isFocused ? '#f0e6f7' : null,
      color: state.isSelected ? 'white' : '#333',
    }),
  };

  return (
    <div style={styles.section}>
      <button
        onClick={() => setIsFiltersVisible(!isFiltersVisible)}
        style={styles.toggleButton}
      >
        <span>Filters</span>
        {isFiltersVisible ? <FaChevronUp /> : <FaChevronDown />}
      </button>
      {isFiltersVisible && (
        <div style={styles.filtersContainer}>
          <div style={styles.grid}>
            <div>
              <label style={styles.label}>Categories</label>
              <Select
                isMulti
                options={categoryOptions}
                value={categoryFilters.map(cat => ({ value: cat, label: cat }))}
                onChange={handleCategoryChange}
                styles={customStyles}
              />
            </div>
            <div>
              <label htmlFor="search-volume-filter" style={styles.label}>
                Minimum Search Volume
              </label>
              <input
                id="search-volume-filter"
                type="number"
                value={searchVolumeFilter}
                onChange={(e) => setSearchVolumeFilter(Number(e.target.value))}
                style={styles.input}
                min="0"
              />
            </div>
            <div>
              <label htmlFor="keyword-filter" style={styles.label}>Keyword Filter</label>
              <input
                id="keyword-filter"
                type="text"
                value={keywordFilter}
                onChange={(e) => setKeywordFilter(e.target.value)}
                placeholder="e.g., kay, kay diamond, kaydiamonds"
                style={styles.input}
              />
            </div>
          </div>
          <div style={styles.checkboxContainer}>
            <label style={styles.checkboxLabel}>
              <input
                type="checkbox"
                checked={showCompetitors}
                onChange={(e) => setShowCompetitors(e.target.checked)}
                style={styles.checkbox}
              />
              <span>Show Competitors</span>
            </label>
            <label style={styles.checkboxLabel}>
              <input
                type="checkbox"
                checked={brandedFilter}
                onChange={(e) => setBrandedFilter(e.target.checked)}
                style={styles.checkbox}
              />
              <span>Branded Only</span>
            </label>
            {showCompetitors && (
              <div style={styles.rankContainer}>
                <label style={styles.label}>Rank Range:</label>
                <input
                  type="number"
                  value={rankRange[0]}
                  onChange={(e) => handleRankRangeChange('min', e.target.value)}
                  style={styles.rankInput}
                  min="1"
                  max="100"
                />
                <span>-</span>
                <input
                  type="number"
                  value={rankRange[1]}
                  onChange={(e) => handleRankRangeChange('max', e.target.value)}
                  style={styles.rankInput}
                  min="1"
                  max="100"
                />
              </div>
            )}
          </div>
          {showCompetitors && (
            <div style={{marginTop: '20px'}}>
              <label style={styles.label}>Select Competitors</label>
              <Select
                isMulti
                options={competitorOptions}
                value={selectedCompetitors.map(comp => ({ value: comp, label: comp }))}
                onChange={handleCompetitorChange}
                styles={customStyles}
              />
            </div>
          )}
        </div>
      )}
    </div>
  );
}

const styles = {
  section: {
    backgroundColor: 'white',
    borderRadius: '12px',
    marginBottom: '40px',
    boxShadow: '0 4px 6px rgba(0,0,0,0.1)',
    transition: 'all 0.3s ease',
  },
  toggleButton: {
    width: '100%',
    backgroundColor: '#6a0dad',
    color: 'white',
    padding: '15px',
    border: 'none',
    borderTopLeftRadius: '12px',
    borderTopRightRadius: '12px',
    cursor: 'pointer',
    display: 'flex',
    justifyContent: 'space-between',
    alignItems: 'center',
    fontSize: '1.2rem',
    fontWeight: 'bold',
  },
  filtersContainer: {
    padding: '30px',
    borderBottomLeftRadius: '12px',
    borderBottomRightRadius: '12px',
    borderTop: 'none',
  },
  grid: {
    display: 'grid',
    gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))',
    gap: '20px',
    marginBottom: '20px',
  },
  label: {
    display: 'block',
    marginBottom: '8px',
    fontSize: '1rem',
    fontWeight: '600',
    color: '#333',
  },
  input: {
    width: '100%',
    padding: '10px',
    border: '1px solid #ddd',
    borderRadius: '4px',
    fontSize: '1rem',
  },
  checkboxContainer: {
    display: 'flex',
    flexWrap: 'wrap',
    alignItems: 'center',
    gap: '20px',
    marginBottom: '20px',
  },
  checkboxLabel: {
    display: 'flex',
    alignItems: 'center',
    fontSize: '1rem',
    color: '#333',
  },
  checkbox: {
    marginRight: '8px',
    width: '18px',
    height: '18px',
    accentColor: '#6a0dad',
  },
  rankContainer: {
    display: 'flex',
    alignItems: 'center',
    gap: '10px',
  },
  rankInput: {
    width: '60px',
    padding: '8px',
    border: '1px solid #ddd',
    borderRadius: '4px',
    fontSize: '1rem',
  },
};

================
File: components/KeywordTable.js
================
import React, { useState, useMemo, useCallback, useEffect } from 'react';
import { BarChart, Bar, XAxis, YAxis, Tooltip, ResponsiveContainer } from 'recharts';

/**
 * KeywordTable Component
 * 
 * This component displays the filtered keyword data in a paginated table format.
 * It also provides functionality for downloading and copying selected keywords,
 * and displays statistics about the selected keywords.
 * 
 * Features:
 * - Displays keywords with their categories and search volumes
 * - Shows competitor information when enabled
 * - Provides checkboxes for selecting individual keywords
 * - Implements pagination for large datasets
 * - Allows for selecting all visible keywords on the current page
 * - Provides buttons for downloading all data, selected data, and copying selected data
 * - Displays statistics about selected keywords
 * 
 * The component receives filtered data, pagination controls, and keyword
 * selection handlers as props from the parent Dashboard component.
 */

const KeywordTable = ({
  filteredData,
  currentPage,
  setCurrentPage,
  showCompetitors,
  selectedKeywords,
  handleKeywordSelect
}) => {
  const [allVisibleSelected, setAllVisibleSelected] = useState(false);
  const itemsPerPage = 100;

  const paginatedData = useMemo(() => {
    const startIndex = (currentPage - 1) * itemsPerPage;
    return filteredData.slice(startIndex, startIndex + itemsPerPage);
  }, [filteredData, currentPage]);

  const handleSelectAllVisible = useCallback((event) => {
    const isChecked = event.target.checked;
    setAllVisibleSelected(isChecked);
    
    const visibleKeywords = paginatedData.map(item => item.keyword);
    visibleKeywords.forEach(keyword => {
      handleKeywordSelect(keyword);
    });
  }, [paginatedData, handleKeywordSelect]);

  useEffect(() => {
    setAllVisibleSelected(false);
  }, [currentPage, filteredData]);

  const capitalizeFirstLetter = (string) => {
    return string.split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
  };

  const downloadCSV = useCallback(() => {
    const csvContent = [
      ['keyword', 'category', 'search volume'],
      ...filteredData.map(item => [item.keyword, item.category, item.searchVolume])
    ].map(row => row.join(',')).join('\n');

    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    if (link.download !== undefined) {
      const url = URL.createObjectURL(blob);
      link.setAttribute('href', url);
      link.setAttribute('download', 'client_gap_analysis.csv');
      link.style.visibility = 'hidden';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }
  }, [filteredData]);

  const copySelectedKeywords = useCallback(() => {
    const selectedData = filteredData
      .filter(item => selectedKeywords.has(item.keyword))
      .map(item => `${item.keyword},${item.category},${item.searchVolume}`)
      .join('\n');
    navigator.clipboard.writeText(`keyword,category,search volume\n${selectedData}`);
    alert('Selected keywords copied to clipboard!');
  }, [filteredData, selectedKeywords]);

  const downloadSelectedKeywords = useCallback(() => {
    const selectedData = filteredData
      .filter(item => selectedKeywords.has(item.keyword))
      .map(item => `${item.keyword},${item.category},${item.searchVolume}`)
      .join('\n');
    const csvContent = `keyword,category,search volume\n${selectedData}`;
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    if (link.download !== undefined) {
      const url = URL.createObjectURL(blob);
      link.setAttribute('href', url);
      link.setAttribute('download', 'selected_keywords.csv');
      link.style.visibility = 'hidden';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }
  }, [filteredData, selectedKeywords]);

  const selectedKeywordsStats = useMemo(() => {
    const selectedItems = filteredData.filter(item => selectedKeywords.has(item.keyword));
    const totalSearchVolume = selectedItems.reduce((sum, item) => sum + item.searchVolume, 0);
    return { totalKeywords: selectedItems.length, totalSearchVolume };
  }, [filteredData, selectedKeywords]);

  return (
    <div style={styles.section}>
      <h2 style={styles.sectionTitle}>Filtered Keywords</h2>
      <div style={styles.buttonContainer}>
        <button onClick={downloadCSV} style={styles.button}>
          Download All CSV
        </button>
        {selectedKeywords.size > 0 && (
          <>
            <button onClick={copySelectedKeywords} style={styles.button}>
              Copy Selected
            </button>
            <button onClick={downloadSelectedKeywords} style={styles.button}>
              Download Selected
            </button>
          </>
        )}
      </div>
      <div style={styles.statsContainer}>
        <p><strong>Total Selected Keywords:</strong> {selectedKeywordsStats.totalKeywords.toLocaleString()}</p>
        <p><strong>Total Search Volume for Selected Keywords:</strong> {selectedKeywordsStats.totalSearchVolume.toLocaleString()}</p>
      </div>
      <div style={{ overflowX: 'auto' }}>
        <table style={styles.table}>
          <thead>
            <tr>
              <th style={styles.th}>
                <input
                  type="checkbox"
                  checked={allVisibleSelected}
                  onChange={handleSelectAllVisible}
                  style={{
                    ...styles.checkbox,
                    width: '18px',
                    height: '18px',
                    cursor: 'pointer',
                    accentColor: '#6a0dad'
                  }}
                />
                Select All
              </th>
              <th style={styles.th}>Keyword</th>
              <th style={styles.th}>Category</th>
              <th style={styles.th}>Search Volume</th>
              {showCompetitors && <th style={styles.th}>Competitors</th>}
            </tr>
          </thead>
          <tbody>
            {paginatedData.map((item, index) => (
              <tr key={item.keyword} style={{backgroundColor: index % 2 === 0 ? '#f8f9fa' : 'white'}}>
                <td style={styles.td}>
                  <input
                    type="checkbox"
                    checked={selectedKeywords.has(item.keyword)}
                    onChange={() => handleKeywordSelect(item.keyword)}
                    style={{
                      ...styles.checkbox,
                      width: '18px',
                      height: '18px',
                      cursor: 'pointer',
                      accentColor: '#6a0dad'
                    }}
                  />
                </td>
                <td style={styles.td}>
                  {capitalizeFirstLetter(item.keyword)}
                  {item.isBranded && (
                    <span style={styles.brandedTag}>Branded</span>
                  )}
                </td>
                <td style={styles.td}>{item.category}</td>
                <td style={styles.td}>{item.searchVolume.toLocaleString()}</td>
                {showCompetitors && (
                  <td style={styles.td}>
                    {item.competitors.map(competitor => (
                      competitor.name === 'client.com' ? (
                        <span key={competitor.name} style={styles.clientTag}>
                          CLIENT: {competitor.rank}
                        </span>
                      ) : (
                        <span key={competitor.name} style={styles.competitorTag}>
                          {competitor.name}: {competitor.rank}
                        </span>
                      )
                    ))}
                  </td>
                )}
              </tr>
            ))}
          </tbody>
        </table>
      </div>
      <div style={{ marginTop: '20px', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
        <button 
          onClick={() => setCurrentPage(prev => Math.max(prev - 1, 1))}
          disabled={currentPage === 1}
          style={{...styles.button, opacity: currentPage === 1 ? 0.5 : 1}}
        >
          Previous
        </button>
        <span style={{fontSize: '1rem', fontWeight: '600'}}>
          Page {currentPage} of {Math.ceil(filteredData.length / itemsPerPage)}
        </span>
        <button 
          onClick={() => setCurrentPage(prev => Math.min(prev + 1, Math.ceil(filteredData.length / itemsPerPage)))}
          disabled={currentPage === Math.ceil(filteredData.length / itemsPerPage)}
          style={{...styles.button, opacity: currentPage === Math.ceil(filteredData.length / itemsPerPage) ? 0.5 : 1}}
        >
          Next
        </button>
      </div>
    </div>
  );
};

const styles = {
  section: {
    backgroundColor: 'white',
    borderRadius: '12px',
    padding: '30px',
    marginBottom: '40px',
    boxShadow: '0 4px 6px rgba(0,0,0,0.1)',
    transition: 'all 0.3s ease',
  },
  sectionTitle: {
    fontSize: '1.8rem',
    marginBottom: '20px',
    color: '#6a0dad',
  },
  buttonContainer: {
    marginBottom: '20px',
  },
  statsContainer: {
    marginBottom: '20px',
  },
  table: {
    width: '100%',
    borderSpacing: '0 10px',
  },
  th: {
    backgroundColor: '#6a0dad',
    color: 'white',
    padding: '15px',
    textAlign: 'left',
  },
  td: {
    padding: '8px',
    borderBottom: '1px solid #eee',
    transition: 'background-color 0.3s ease',
  },
  checkbox: {
    marginRight: '8px',
    accentColor: '#6a0dad',
  },
  brandedTag: {
    backgroundColor: '#6a0dad',
    color: 'white',
    padding: '4px 8px',
    borderRadius: '20px',
    fontSize: '0.8em',
    marginLeft: '8px',
    fontWeight: '600',
  },
  competitorTag: {
    display: 'inline-block',
    padding: '2px 6px',
    margin: '2px',
    borderRadius: '12px',
    fontSize: '0.8em',
    backgroundColor: '#e0e0e0',
    color: '#333',
  },
  clientTag: {
    display: 'inline-block',
    padding: '2px 6px',
    margin: '2px',
    borderRadius: '12px',
    fontSize: '0.8em',
    background: 'linear-gradient(45deg, #FF9A8B 0%, #FF6A88 55%, #FF99AC 100%)',
    color: 'white',
    fontWeight: 'bold',
  },
  button: {
    backgroundColor: '#6a0dad',
    color: 'white',
    border: 'none',
    padding: '12px 20px',
    borderRadius: '8px',
    cursor: 'pointer',
    fontSize: '1rem',
    fontWeight: '600',
    transition: 'background-color 0.3s ease',
    marginRight: '10px',
  },
};

export default KeywordTable;

================
File: components/Sidebar.js
================
import React, { useEffect, useState, useRef } from 'react';
import { FaTable, FaChartBar, FaUsers, FaFilter, FaTags, FaChevronRight } from 'react-icons/fa';

const Sidebar = ({ 
  isOpen, 
  toggleSidebar, 
  activeView, 
  setActiveView,
  categories = [],
  competitors = [],
  categoryFilters,
  setCategoryFilters,
  selectedCompetitors,
  setSelectedCompetitors
}) => {
  const [scrollPosition, setScrollPosition] = useState(0);
  const [expandedSection, setExpandedSection] = useState(null);
  const sidebarRef = useRef(null);

  useEffect(() => {
    const handleScroll = () => {
      setScrollPosition(window.pageYOffset);
    };

    const handleClickOutside = (event) => {
      if (sidebarRef.current && !sidebarRef.current.contains(event.target) && isOpen) {
        toggleSidebar();
      }
    };

    window.addEventListener('scroll', handleScroll);
    document.addEventListener('mousedown', handleClickOutside);

    return () => {
      window.removeEventListener('scroll', handleScroll);
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, [isOpen, toggleSidebar]);

  const handleMenuItemClick = (view) => {
    setActiveView(view);
    if (window.innerWidth < 768) {
      toggleSidebar();
    }
  };

  const toggleSection = (section) => {
    setExpandedSection(expandedSection === section ? null : section);
  };

  const handleCategoryToggle = (category) => {
    setCategoryFilters(prev => {
      const newFilters = prev.includes(category)
        ? prev.filter(c => c !== category)
        : [...prev, category];
      return newFilters;
    });
  };

  const handleCompetitorToggle = (competitor) => {
    setSelectedCompetitors(prev => {
      const newSelection = prev.includes(competitor)
        ? prev.filter(c => c !== competitor)
        : [...prev, competitor];
      return newSelection;
    });
  };

  const sidebarStyle = {
    ...styles.sidebar,
    transform: isOpen ? 'translateX(0)' : 'translateX(-100%)',
    top: scrollPosition > 64 ? '0px' : '64px',
  };

  return (
    <div style={sidebarStyle} ref={sidebarRef}>
      <div style={styles.header}>
        <h2 style={styles.title}>Dashboard</h2>
        <button onClick={toggleSidebar} style={styles.closeButton}>×</button>
      </div>

      <div style={styles.menuItems}>
        {/* Main Views */}
        <div style={styles.section}>
          <button 
            onClick={() => handleMenuItemClick('keywordTable')}
            style={{
              ...styles.menuItem,
              backgroundColor: activeView === 'keywordTable' ? '#6a0dad' : 'transparent',
              color: activeView === 'keywordTable' ? 'white' : '#333'
            }}
          >
            <FaTable style={styles.icon} /> Keyword Table
          </button>
          <button 
            onClick={() => handleMenuItemClick('categoryAnalysis')}
            style={{
              ...styles.menuItem,
              backgroundColor: activeView === 'categoryAnalysis' ? '#6a0dad' : 'transparent',
              color: activeView === 'categoryAnalysis' ? 'white' : '#333'
            }}
          >
            <FaChartBar style={styles.icon} /> Category Analysis
          </button>
          <button 
            onClick={() => handleMenuItemClick('competitorAnalysis')}
            style={{
              ...styles.menuItem,
              backgroundColor: activeView === 'competitorAnalysis' ? '#6a0dad' : 'transparent',
              color: activeView === 'competitorAnalysis' ? 'white' : '#333'
            }}
          >
            <FaUsers style={styles.icon} /> Competitor Analysis
          </button>
        </div>

        {/* Categories Section */}
        <div style={styles.section}>
          <button 
            onClick={() => toggleSection('categories')}
            style={styles.sectionHeader}
          >
            <FaTags style={styles.icon} />
            Categories
            <FaChevronRight style={{
              ...styles.chevron,
              transform: expandedSection === 'categories' ? 'rotate(90deg)' : 'none'
            }} />
          </button>
          {expandedSection === 'categories' && (
            <div style={styles.filterList}>
              {categories.map(category => (
                <label key={category} style={styles.filterItem}>
                  <input
                    type="checkbox"
                    checked={categoryFilters.includes(category)}
                    onChange={() => handleCategoryToggle(category)}
                    style={styles.checkbox}
                  />
                  <span style={styles.filterLabel}>{category}</span>
                </label>
              ))}
            </div>
          )}
        </div>

        {/* Competitors Section */}
        <div style={styles.section}>
          <button 
            onClick={() => toggleSection('competitors')}
            style={styles.sectionHeader}
          >
            <FaUsers style={styles.icon} />
            Competitors
            <FaChevronRight style={{
              ...styles.chevron,
              transform: expandedSection === 'competitors' ? 'rotate(90deg)' : 'none'
            }} />
          </button>
          {expandedSection === 'competitors' && (
            <div style={styles.filterList}>
              {competitors.map(competitor => (
                <label key={competitor} style={styles.filterItem}>
                  <input
                    type="checkbox"
                    checked={selectedCompetitors.includes(competitor)}
                    onChange={() => handleCompetitorToggle(competitor)}
                    style={styles.checkbox}
                  />
                  <span style={styles.filterLabel}>{competitor}</span>
                </label>
              ))}
            </div>
          )}
        </div>
      </div>
    </div>
  );
};

const styles = {
  sidebar: {
    position: 'fixed',
    left: 0,
    bottom: 0,
    width: '280px',
    backgroundColor: '#f8f9fa',
    boxShadow: '2px 0 5px rgba(0,0,0,0.1)',
    zIndex: 1000,
    display: 'flex',
    flexDirection: 'column',
    transition: 'transform 0.3s ease-in-out, top 0.3s ease-in-out',
    height: '100%',
  },
  header: {
    display: 'flex',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: '20px',
    borderBottom: '1px solid #e0e0e0',
  },
  title: {
    margin: 0,
    fontSize: '1.2rem',
    fontWeight: 'bold',
    color: '#333',
  },
  closeButton: {
    background: 'none',
    border: 'none',
    fontSize: '24px',
    cursor: 'pointer',
    color: '#666',
  },
  menuItems: {
    display: 'flex',
    flexDirection: 'column',
    padding: '20px 0',
    overflowY: 'auto',
  },
  section: {
    marginBottom: '20px',
  },
  sectionHeader: {
    display: 'flex',
    alignItems: 'center',
    width: '100%',
    padding: '10px 20px',
    border: 'none',
    backgroundColor: 'transparent',
    fontSize: '1rem',
    cursor: 'pointer',
    color: '#333',
    fontWeight: '500',
  },
  menuItem: {
    display: 'flex',
    alignItems: 'center',
    width: '100%',
    padding: '12px 20px',
    border: 'none',
    borderRadius: '0',
    textAlign: 'left',
    fontSize: '1rem',
    cursor: 'pointer',
    transition: 'background-color 0.3s ease, color 0.3s ease',
    marginBottom: '2px',
  },
  icon: {
    marginRight: '10px',
    fontSize: '16px',
  },
  chevron: {
    marginLeft: 'auto',
    fontSize: '12px',
    transition: 'transform 0.3s ease',
  },
  filterList: {
    padding: '10px 0',
  },
  filterItem: {
    display: 'flex',
    alignItems: 'center',
    padding: '8px 20px 8px 40px',
    cursor: 'pointer',
  },
  checkbox: {
    marginRight: '10px',
    cursor: 'pointer',
  },
  filterLabel: {
    fontSize: '0.9rem',
    color: '#444',
  },
};

export default Sidebar;

================
File: pages/index.js
================
import React, { useState, useMemo, useCallback, useEffect } from 'react';
import Head from 'next/head';
import Filters from '../components/Filters';
import KeywordTable from '../components/KeywordTable';
import CategoryAnalysis from '../components/CategoryAnalysis';
import BrandedAnalysis from '../components/BrandedAnalysis';
import CategoryDistribution from '../components/CategoryDistribution';
import CompetitorAnalysis from '../components/CompetitorAnalysis';
import Sidebar from '../components/Sidebar';
import DataLoader from '../components/DataLoader';

const ClientKeywordsAnalysis = () => {
  const [keywordData, setKeywordData] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  const [dataLoaded, setDataLoaded] = useState(false);

  // Other state management
  const [categoryFilters, setCategoryFilters] = useState([]);
  const [searchVolumeFilter, setSearchVolumeFilter] = useState(0);
  const [brandedFilter, setBrandedFilter] = useState(false);
  const [keywordFilter, setKeywordFilter] = useState('');
  const [chartMetric, setChartMetric] = useState('searchVolume');
  const [currentPage, setCurrentPage] = useState(1);
  const [showCompetitors, setShowCompetitors] = useState(true);
  const [selectedCompetitors, setSelectedCompetitors] = useState([]);
  const [rankRange, setRankRange] = useState([1, 10]);
  const [competitorDataType, setCompetitorDataType] = useState('count');
  const [selectedKeywords, setSelectedKeywords] = useState(new Set());
  const [sidebarOpen, setSidebarOpen] = useState(false);
  const [activeView, setActiveView] = useState('keywordTable');
  const [scrollPosition, setScrollPosition] = useState(0);

  useEffect(() => {
    const handleScroll = () => {
      setScrollPosition(window.pageYOffset);
    };

    window.addEventListener('scroll', handleScroll);
    return () => {
      window.removeEventListener('scroll', handleScroll);
    };
  }, []);

  const handleDataLoad = (data) => {
    setKeywordData(data);
    setDataLoaded(true);
    setIsLoading(false);
  };

  const filteredData = useMemo(() => {
    if (!keywordData.length) return [];

    return keywordData.filter(item => {
      const categoryMatch = categoryFilters.length === 0 || categoryFilters.includes(item.category);
      const volumeMatch = item.searchVolume >= searchVolumeFilter;
      const brandedMatch = !brandedFilter || item.isBranded;
      const keywordMatch = keywordFilter === '' || 
        keywordFilter.split(',').some(keyword => 
          item.keyword.toLowerCase().includes(keyword.trim().toLowerCase())
        );
      const competitorMatch = item.competitors.some(comp => 
        (selectedCompetitors.length === 0 || selectedCompetitors.includes(comp.name)) &&
        comp.rank >= rankRange[0] && comp.rank <= rankRange[1]
      );

      return categoryMatch && volumeMatch && brandedMatch && keywordMatch && competitorMatch;
    });
  }, [keywordData, categoryFilters, searchVolumeFilter, brandedFilter, keywordFilter, selectedCompetitors, rankRange]);

  const handleKeywordSelect = useCallback((keyword) => {
    setSelectedKeywords(prev => {
      const newSet = new Set(prev);
      if (newSet.has(keyword)) {
        newSet.delete(keyword);
      } else {
        newSet.add(keyword);
      }
      return newSet;
    });
  }, []);

  const toggleSidebar = () => setSidebarOpen(!sidebarOpen);

  return (
    <div className="max-w-7xl mx-auto p-8 bg-gray-50 text-gray-800 font-sans">
      <Head>
        <title>Content Gap Analysis Dashboard</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
      </Head>

      <Filters
        data={keywordData}  // Add this line
        categoryFilters={categoryFilters}
        setCategoryFilters={setCategoryFilters}
        searchVolumeFilter={searchVolumeFilter}
        setSearchVolumeFilter={setSearchVolumeFilter}
        brandedFilter={brandedFilter}
        setBrandedFilter={setBrandedFilter}
        keywordFilter={keywordFilter}
        setKeywordFilter={setKeywordFilter}
        showCompetitors={showCompetitors}
        setShowCompetitors={setShowCompetitors}
        selectedCompetitors={selectedCompetitors}
        setSelectedCompetitors={setSelectedCompetitors}
        rankRange={rankRange}
        setRankRange={setRankRange}
      />
      
      <div className="ml-0 transition-all duration-300 ease-in-out">
        <button 
          onClick={toggleSidebar} 
          className={`fixed left-5 z-50 bg-purple-700 text-white border-none rounded p-3 text-xl cursor-pointer transition-all duration-300 ease-in-out ${
            scrollPosition > 64 ? 'top-5' : 'top-20'
          }`}
        >
          ☰
        </button>

        <h1 className="text-4xl font-bold text-center text-purple-700 pb-5 mb-10 border-b-2 border-purple-700">
          Content Gap Analysis Dashboard
        </h1>

        <DataLoader 
          onDataLoad={handleDataLoad}
          isLoading={isLoading}
        />
        
        {dataLoaded ? (
          <>
            <Filters
              categoryFilters={categoryFilters}
              setCategoryFilters={setCategoryFilters}
              searchVolumeFilter={searchVolumeFilter}
              setSearchVolumeFilter={setSearchVolumeFilter}
              brandedFilter={brandedFilter}
              setBrandedFilter={setBrandedFilter}
              keywordFilter={keywordFilter}
              setKeywordFilter={setKeywordFilter}
              showCompetitors={showCompetitors}
              setShowCompetitors={setShowCompetitors}
              selectedCompetitors={selectedCompetitors}
              setSelectedCompetitors={setSelectedCompetitors}
              rankRange={rankRange}
              setRankRange={setRankRange}
            />

            <div className="mb-8">
              <h2 className="text-2xl font-semibold mb-4 text-purple-700">Select View</h2>
              <div className="flex flex-wrap gap-4">
                <button
                  onClick={() => setActiveView('keywordTable')}
                  className={`px-4 py-2 rounded ${activeView === 'keywordTable' ? 'bg-purple-700 text-white' : 'bg-gray-200'}`}
                >
                  Keyword Table
                </button>
                <button
                  onClick={() => setActiveView('categoryAnalysis')}
                  className={`px-4 py-2 rounded ${activeView === 'categoryAnalysis' ? 'bg-purple-700 text-white' : 'bg-gray-200'}`}
                >
                  Category Analysis
                </button>
                <button
                  onClick={() => setActiveView('competitorAnalysis')}
                  className={`px-4 py-2 rounded ${activeView === 'competitorAnalysis' ? 'bg-purple-700 text-white' : 'bg-gray-200'}`}
                >
                  Competitor Analysis
                </button>
              </div>
            </div>

            {activeView === 'keywordTable' && (
              <KeywordTable
                filteredData={filteredData}
                currentPage={currentPage}
                setCurrentPage={setCurrentPage}
                showCompetitors={showCompetitors}
                selectedKeywords={selectedKeywords}
                handleKeywordSelect={handleKeywordSelect}
              />
            )}

            {activeView === 'categoryAnalysis' && (
              <>
                <CategoryAnalysis
                  filteredData={filteredData}
                  chartMetric={chartMetric}
                  setChartMetric={setChartMetric}
                />
                <BrandedAnalysis
                  filteredData={filteredData}
                  chartMetric={chartMetric}
                />
                <CategoryDistribution
                  filteredData={filteredData}
                  chartMetric={chartMetric}
                />
              </>
            )}

            {activeView === 'competitorAnalysis' && (
              <CompetitorAnalysis
                filteredData={filteredData}
                competitorDataType={competitorDataType}
                setCompetitorDataType={setCompetitorDataType}
              />
            )}
          </>
        ) : (
          <div className="text-center p-8 bg-white rounded-lg shadow-md">
            <h2 className="text-2xl text-gray-700 mb-4">Welcome to the Content Gap Analysis Dashboard</h2>
            <p className="text-gray-600">Please enter a data URL above and click "Load Data" to begin.</p>
            <p className="text-gray-500 mt-2 text-sm">Example JSON format:</p>
            <pre className="bg-gray-100 p-4 rounded-lg mt-2 text-left overflow-x-auto">
              {JSON.stringify([
                {
                  "keyword": "example keyword",
                  "category": "category name",
                  "searchVolume": 1000,
                  "isBranded": false,
                  "competitors": [
                    {"name": "competitor.com", "rank": 1}
                  ]
                }
              ], null, 2)}
            </pre>
          </div>
        )}
      </div>
    </div>
  );
};

export default ClientKeywordsAnalysis;

================
File: public/_app.js
================
import '../styles/index.css'
import 'rc-slider/assets/index.css'

function MyApp({ Component, pageProps }) {
  return (
    <div className="font-sans">
      <Component {...pageProps} />
    </div>
  )
}

export default MyApp

================
File: styles/index.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

/* You can add any custom styles below this line */

================
File: .gitattributes
================
# Auto detect text files and perform LF normalization
* text=auto

================
File: .gitignore
================
# Dependencies
/node_modules

/public/data.js
/public/kay.js

# Next.js build output
/.next
/out

# Production build
/build

# Random Old Files
/old

# Misc
.DS_Store
*.pem

# Debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Local env files
.env*.local

# Vercel
.vercel

# TypeScript
*.tsbuildinfo
next-env.d.ts

# Editor directories and files
.idea
.vscode
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

================
File: next.config.js
================
module.exports = {
    reactStrictMode: true,
    webpack: (config, { isServer }) => {
      if (!isServer) {
        config.resolve.fallback = {
          ...config.resolve.fallback,
          fs: false,
          module: false,
        };
      }
      return config;
    },
  };

================
File: nextjs_project_structure.csv
================
Path,Description,File Content
content_gap_dashboard_js/,Project folder
  tailwind.config.js,JavaScript file,"Text file, no specific patterns found"
  .DS_Store,Project file,Binary file or non-UTF-8 encoded text file
  next.config.js,Next.js configuration file,"Text file, no specific patterns found"
  process.config.js,JavaScript file,"Text file, no specific patterns found"
  package-lock.json,JSON configuration file,Binary file (MIME type: application/json)
  package.json,Node.js package configuration,Binary file (MIME type: application/json)
  structure.py,Project file,"Text file, no specific patterns found"
  old/,Project folder
    nextjs_project_structure.csv,Project file,"Text file, no specific patterns found"
    .DS_Store,Project file,Binary file or non-UTF-8 encoded text file
    Screen Recording 2024-09-30 at 4.55.48 PM.mov,Project file,Binary file (MIME type: video/quicktime)
    ipsy-keywords copy.js,JavaScript file,"Text file, no specific patterns found"
    ipsy-keywords.js,JavaScript file,"Text file, no specific patterns found"
  styles/,CSS or styling related files
    index.css,CSS stylesheet,"Text file, no specific patterns found"
  components/,Reusable React components
    DynamicSlider.js,JavaScript file,"Text file, no specific patterns found"
    CategoryDistribution.js,JavaScript file,"Text file, no specific patterns found"
    Sidebar.js,JavaScript file,"Text file, no specific patterns found"
    CategoryAnalysis.js,JavaScript file,"Text file, no specific patterns found"
    CompetitorAnalysis.js,JavaScript file,"Text file, no specific patterns found"
    Filters.js,JavaScript file,"Text file, no specific patterns found"
    KeywordTable.js,JavaScript file,"Text file, no specific patterns found"
    QuestionsAnalysis.js,JavaScript file,"Text file, no specific patterns found"
    Dashboard.js,JavaScript file,"Text file, no specific patterns found"
  public/,Static assets served directly by Next.js
    _app.js,JavaScript file,React component
    data.js,JavaScript file,"Text file, no specific patterns found"
    ._data.js,JavaScript file,Binary file or non-UTF-8 encoded text file
  pages/,Contains page components and routing structure
    index.js,JavaScript file,"Text file, no specific patterns found"

================
File: package.json
================
{
    "name": "content-gap-analysis",
    "version": "1.0.0",
    "description": "Client Keywords Analysis Dashboard for Gap Analysis",
    "main": "index.js",
    "scripts": {
        "dev": "next dev",
        "build": "next build",
        "start": "next start",
        "lint": "next lint"
    },
    "dependencies": {
        "@google-cloud/storage": "^6.0.0",
        "autoprefixer": "^10.4.20",
        "lucide-react": "^0.452.0",
        "next": "^14.2.13",
        "postcss": "^8.4.47",
        "rc-slider": "^10.1.0",
        "react": "^18.2.0",
        "react-dom": "^18.2.0",
        "react-icons": "^4.12.0",
        "react-select": "^5.8.1",
        "recharts": "^2.5.0",
        "tailwindcss": "^3.4.13"
    },
    "devDependencies": {
        "@types/node": "^20.0.0",
        "@types/react": "^18.2.0",
        "eslint": "^8.0.0",
        "eslint-config-next": "^14.0.0",
        "typescript": "^5.0.0"
    }
}

================
File: process.config.js
================
module.exports = {
    plugins: {
      tailwindcss: {},
      autoprefixer: {},
    },
  }

================
File: README.md
================
# Gap Analysis Dashboard

## Overview

The Client's Gap Analysis Dashboard is a powerful tool designed to analyze keyword data, providing insights into search volumes, competitor rankings, and category distributions. This React-based application offers a user-friendly interface for filtering and visualizing complex keyword data sets.

## Features

- **Advanced Filtering**: Filter keywords by category, search volume, competitor presence, and more.
- **Multiple Views**: 
  - Keyword Table: Detailed view of individual keywords and their metrics.
  - Category Analysis: Visualize data distribution across different categories.
  - Competitor Analysis: Understand your position relative to competitors.
- **Interactive Charts**: Dynamically updated charts for visual data representation.
- **Responsive Design**: Fully responsive layout that works on desktop and mobile devices.

## Technology Stack

- React.js
- Next.js
- Tailwind CSS
- recharts (for data visualization)
- react-select (for advanced select inputs)

## Getting Started

### Prerequisites

- Node.js (v14 or later)
- npm (v6 or later)

### Installation

1. Clone the repository:
   ```
   git clone https://github.com/your-username/client-gap-analysis-dashboard.git
   ```

2. Navigate to the project directory:
   ```
   cd client-gap-analysis-dashboard
   ```

3. Install dependencies:
   ```
   npm install
   ```

4. Start the development server:
   ```
   npm run dev
   ```

5. Open your browser and visit `http://localhost:3000`

## Project Structure

```
client-gap-analysis-dashboard/
├── components/
│   ├── CategoryAnalysis.js
│   ├── CategoryDistribution.js
│   ├── CompetitorAnalysis.js
│   ├── Filters.js
│   ├── KeywordTable.js
│   ├── QuestionsAnalysis.js
│   └── Sidebar.js
├── pages/
│   └── index.js
├── public/
│   └── data.js
├── styles/
│   └── index.css
├── package.json
├── next.config.js
└── README.md
```

## Usage

1. **Filtering Data**: 
   - Use the Filters section at the top of the dashboard to narrow down the keyword data.
   - Select categories, set minimum search volume, filter by keyword, and more.

2. **Viewing Data**:
   - Switch between different views using the "Select View" buttons.
   - Keyword Table: Shows detailed information about each keyword.
   - Category Analysis: Provides charts and insights about category distribution.
   - Competitor Analysis: Visualizes your position compared to competitors.

3. **Interacting with Charts**:
   - Hover over chart elements to see detailed information.
   - Some charts allow you to click on elements to filter the data further.

4. **Exporting Data**:
   - Use the "Download All CSV" button to export the filtered data set.

## Customization

- To add or modify data, edit the `public/data.js` file.
- Styling can be customized in `styles/index.css` or by modifying Tailwind classes in component files.

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

## License

This project is licensed under the MIT License - see the LICENSE file for details.

## Support

If you encounter any problems or have any questions, please open an issue in the GitHub repository.

================
File: structure.py
================
import os
import csv
import re
import mimetypes

def analyze_nextjs_project(root_dir):
    project_structure = []

    for dirpath, dirnames, filenames in os.walk(root_dir):
        depth = dirpath[len(root_dir):].count(os.sep)
        indent = '  ' * depth
        folder_name = os.path.basename(dirpath)

        if '.next' in dirnames:
            dirnames.remove('.next')  # Skip .next directory
        if 'node_modules' in dirnames:
            dirnames.remove('node_modules')  # Skip node_modules directory

        description = get_folder_description(folder_name)
        project_structure.append([f"{indent}{folder_name}/", description])

        for filename in filenames:
            file_path = os.path.join(dirpath, filename)
            file_description = get_file_description(filename)
            file_content = search_file_content(file_path)
            project_structure.append([f"{indent}  {filename}", file_description, file_content])

    return project_structure

def get_folder_description(folder_name):
    descriptions = {
        'pages': 'Contains page components and routing structure',
        'components': 'Reusable React components',
        'styles': 'CSS or styling related files',
        'public': 'Static assets served directly by Next.js',
        'lib': 'Custom libraries or utility functions',
        'api': 'API routes for server-side functionality',
        'contexts': 'React context providers',
        'hooks': 'Custom React hooks',
        'config': 'Configuration files',
        'tests': 'Test files and test-related utilities',
    }
    return descriptions.get(folder_name, 'Project folder')

def get_file_description(filename):
    _, ext = os.path.splitext(filename)
    descriptions = {
        '.js': 'JavaScript file',
        '.jsx': 'React component file',
        '.ts': 'TypeScript file',
        '.tsx': 'TypeScript React component file',
        '.css': 'CSS stylesheet',
        '.scss': 'SASS stylesheet',
        '.json': 'JSON configuration file',
        '.md': 'Markdown documentation file',
        'package.json': 'Node.js package configuration',
        'next.config.js': 'Next.js configuration file',
        '.env': 'Environment variables file',
        '.gitignore': 'Git ignore rules',
    }
    return descriptions.get(filename, descriptions.get(ext, 'Project file'))

def search_file_content(file_path):
    mime_type, _ = mimetypes.guess_type(file_path)
    
    if mime_type and not mime_type.startswith('text'):
        return f"Binary file (MIME type: {mime_type})"

    try:
        with open(file_path, 'r', encoding='utf-8') as file:
            content = file.read()
            
            patterns = {
                'React component': r'function\s+\w+\s*\([^)]*\)\s*{\s*return\s*\(',
                'API route': r'export\s+default\s+function\s+handler\s*\(',
                'getServerSideProps': r'export\s+async\s+function\s+getServerSideProps',
                'getStaticProps': r'export\s+async\s+function\s+getStaticProps',
                'getStaticPaths': r'export\s+async\s+function\s+getStaticPaths',
                'Custom hook': r'function\s+use\w+\s*\(',
                'Context provider': r'export\s+const\s+\w+Context\s*=\s*createContext',
            }
            
            findings = []
            for key, pattern in patterns.items():
                if re.search(pattern, content):
                    findings.append(key)
            
            return ', '.join(findings) if findings else 'Text file, no specific patterns found'
    except UnicodeDecodeError:
        return "Binary file or non-UTF-8 encoded text file"
    except Exception as e:
        return f"Error reading file: {str(e)}"

def export_to_csv(data, output_file):
    with open(output_file, 'w', newline='', encoding='utf-8') as csvfile:
        writer = csv.writer(csvfile)
        writer.writerow(['Path', 'Description', 'File Content'])
        writer.writerows(data)

def export_to_txt(data, output_file):
    with open(output_file, 'w', encoding='utf-8') as txtfile:
        for item in data:
            txtfile.write(f"{item[0]:<40} {item[1]}\n")
            if len(item) > 2:
                txtfile.write(f"  Content: {item[2]}\n")
            txtfile.write('\n')

if __name__ == '__main__':
    project_root = input("Enter the path to your Next.js project root (press Enter for current directory): ").strip()
    if not project_root:
        project_root = os.getcwd()

    output_format = input("Enter the desired output format (csv/txt, press Enter for csv): ").lower().strip()
    if not output_format:
        output_format = 'csv'

    structure = analyze_nextjs_project(project_root)

    if output_format == 'csv':
        output_file = 'nextjs_project_structure.csv'
        export_to_csv(structure, output_file)
    elif output_format == 'txt':
        output_file = 'nextjs_project_structure.txt'
        export_to_txt(structure, output_file)
    else:
        print("Invalid output format. Using default 'csv' format.")
        output_file = 'nextjs_project_structure.csv'
        export_to_csv(structure, output_file)

    print(f"Project structure exported to {output_file}")

================
File: tailwind.config.js
================
module.exports = {
    content: [
      "./pages/**/*.{js,ts,jsx,tsx}",
      "./components/**/*.{js,ts,jsx,tsx}",
    ],
    theme: {
      extend: {},
    },
    plugins: [],
  }

================
File: vercel.json
================
{
    "version": 2,
    "builds": [
      {
        "src": "package.json",
        "use": "@vercel/next"
      }
    ]
  }
